"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.option_annot_to_mich_type = exports.option_to_mich_type = exports.contract_annot_to_mich_type = exports.contract_to_mich_type = exports.mich_array_to_mich = exports.pair_array_to_mich_type = exports.pair_annot_to_mich_type = exports.pair_to_mich_type = exports.pair_to_mich = exports.or_to_mich_type = exports.right_to_mich = exports.left_to_mich = exports.elt_to_mich = exports.date_to_mich = exports.bool_to_mich = exports.string_to_mich = exports.unit_to_mich = exports.unit_mich = exports.prim_annot_to_mich_type = exports.prim_to_mich_type = exports.Unit = exports.Ticket = exports.Tez = exports.Signature = exports.Sapling_transaction = exports.Sapling_state = exports.Rational = exports.Or = exports.Option = exports.Nat = exports.Key_hash = exports.Key = exports.Int = exports.Enum = exports.Entrypoint = exports.Duration = exports.Chest_key = exports.Chest = exports.Chain_id = exports.Bytes = exports.Bls12_381_g2 = exports.Bls12_381_g1 = exports.Bls12_381_fr = exports.Address = exports.getter_args_to_mich = exports.list_equals = exports.micheline_equals = exports.some_to_mich = exports.none_mich = exports.ArchetypeType = void 0;
exports.normalize = exports.replace_var = exports.is_right = exports.is_left = exports.mich_to_map = exports.mich_to_list = exports.mich_to_bool = exports.mich_to_date = exports.mich_to_string = exports.annotated_mich_to_array = exports.mich_to_pairs = exports.date_cmp = exports.string_cmp = exports.set_to_mich = exports.set_annot_to_mich_type = exports.set_to_mich_type = exports.list_annot_to_mich_type = exports.list_to_mich_type = exports.list_to_mich = exports.ticket_annot_to_mich_type = exports.ticket_to_mich_type = void 0;
const bignumber_js_1 = require("bignumber.js");
const bs58check_1 = __importDefault(require("bs58check"));
/* Archetype value */
class ArchetypeType {
}
exports.ArchetypeType = ArchetypeType;
/* Constants --------------------------------------------------------------- */
exports.none_mich = {
    "prim": "None"
};
const some_to_mich = (a) => {
    return {
        prim: "Some",
        args: [a]
    };
};
exports.some_to_mich = some_to_mich;
/* Utils ------------------------------------------------------------------- */
const micheline_equals = (lhs, rhs) => {
    return JSON.stringify(lhs, null, 0) == JSON.stringify(rhs, null, 0);
};
exports.micheline_equals = micheline_equals;
const list_equals = (l1, l2, cmp) => {
    if (l1.length == l2.length) {
        for (let i = 0; i < l1.length; i++) {
            if (!cmp(l1[i], l2[i])) {
                return false;
            }
        }
        return true;
    }
    return false;
};
exports.list_equals = list_equals;
const getter_args_to_mich = (arg, callback) => {
    return (0, exports.pair_to_mich)([arg, callback.to_mich()]);
};
exports.getter_args_to_mich = getter_args_to_mich;
const is_base58_input_valid = (input, prefixes) => {
    const prefixes_keys = Object.keys(prefixes);
    const match = new RegExp(`^(${prefixes_keys.join('|')})`).exec(input);
    if (!match || match.length == 0)
        throw new Error(`No matching prefix found. Received input: ${input}`);
    let decoded = bs58check_1.default.decodeUnsafe(input);
    if (!decoded)
        throw new Error(`Input is not b58 encoding compatible. Received input: ${input}`);
    const prefix = match[0];
    decoded = decoded.subarray(prefix.length);
    if (decoded.length != prefixes[prefix].size)
        throw new Error(`The decoded output is the wrong length for the given prefix of ${prefix}.`);
    return input;
};
/* Internal constants ---------------------------------------------------------- */
const address_prefixes = {
    tz1: { size: 20, prefix: "\\006\\161\\159" },
    tz2: { size: 20, prefix: "\\006\\161\\161" },
    tz3: { size: 20, prefix: "\\006\\161\\164" },
    tz4: { size: 20, prefix: "\\006\\161\\166" },
    KT1: { size: 20, prefix: "\\002\\090\\121" },
    sr1: { size: 20, prefix: "\\006\\124\\117" }
};
const public_key_prefixes = {
    edpk: { size: 32, prefix: "\\013\\015\\037\\217" },
    sppk: { size: 33, prefix: "\\003\\254\\226\\086" },
    p2pk: { size: 33, prefix: "\\003\\178\\139\\127" },
};
const signature_prefixes = {
    sig: { size: 64, prefix: "\\004\\130\\043" },
    edsig: { size: 64, prefix: "\\009\\245\\205\\134\\018" },
    spsig: { size: 64, prefix: "\\013\\115\\101\\019\\063" },
    p2sig: { size: 63, prefix: "\\054\\240\\044\\052" }
};
const chain_id_prefixes = {
    Net: { size: 4, prefix: "\\087\\082\\000" }
};
const prefixes = Object.assign(Object.assign(Object.assign(Object.assign({}, address_prefixes), public_key_prefixes), signature_prefixes), chain_id_prefixes);
/* Int Nat Entrypoint Classes ---------------------------------------------- */
// Function to convert a hexadecimal string to a Buffer object
function hexStringToBuffer(hexString) {
    // Check if the input is a valid hexadecimal string
    if (!/^([0-9a-fA-F]{2})+$/.test(hexString)) {
        throw new Error('Invalid hexadecimal string provided.');
    }
    // Convert the hexadecimal string to a Buffer object
    const buffer = Buffer.from(hexString, 'hex');
    return buffer;
}
function escapeSequenceToHexString(input) {
    const regex = /\\(\d{3})/g;
    let hexString = '';
    input.replace(regex, (_, octalString) => {
        const octal = parseInt(octalString, 10);
        const hex = octal.toString(16).padStart(2, '0');
        hexString += hex;
        return '';
    });
    return hexString;
}
function encode_prefix(prefix, data) {
    return bs58check_1.default.encode(hexStringToBuffer(escapeSequenceToHexString(prefix) + data));
}
function extract_address_input(input) {
    const first = input.substring(0, 2);
    switch (first) {
        case "00": {
            const second = input.substring(2, 4);
            const data = input.substring(4);
            const a = (() => {
                switch (second) {
                    case "00": return prefixes.tz1;
                    case "01": return prefixes.tz2;
                    case "02": return prefixes.tz3;
                    case "03": return prefixes.tz4;
                    default: throw new Error(`Unknown implicit address: 0x${second}`);
                }
            })();
            return [a.prefix, data];
        }
        case "01": {
            const data = input.substring(2, 42);
            return [prefixes.KT1.prefix, data];
        }
        case "03": {
            const data = input.substring(2, 42);
            return [prefixes.sr1.prefix, data];
        }
        default: throw new Error(`Invalid input: 0x${input}`);
    }
}
class Address {
    constructor(v) {
        this._content = is_base58_input_valid(v, address_prefixes);
    }
    to_mich() {
        return (0, exports.string_to_mich)(this._content);
    }
    static from_mich(x) {
        if (x["bytes"]) {
            const input = x["bytes"];
            const [prefix, data] = extract_address_input(input);
            return new Address(encode_prefix(prefix, data));
        }
        else {
            return new Address(x["string"]);
        }
    }
    equals(a) {
        return this._content == a.toString();
    }
    toString() {
        return this._content;
    }
}
exports.Address = Address;
class Bls12_381_fr {
    constructor(v) {
        this.equals = (x) => {
            return this._content == x.toString();
        };
        this.toString = () => {
            return this._content;
        };
        /* TODO check value validity */
        this._content = v;
    }
    to_mich() {
        return {
            "bytes": this._content
        };
    }
    static from_mich(x) {
        return new Bls12_381_fr(x["bytes"]);
    }
}
exports.Bls12_381_fr = Bls12_381_fr;
class Bls12_381_g1 {
    constructor(v) {
        this.equals = (x) => {
            return this._content == x.toString();
        };
        this.toString = () => {
            return this._content;
        };
        /* TODO check value validity */
        this._content = v;
    }
    to_mich() {
        return {
            "bytes": this._content
        };
    }
    static from_mich(x) {
        return new Bls12_381_g1(x["bytes"]);
    }
}
exports.Bls12_381_g1 = Bls12_381_g1;
class Bls12_381_g2 {
    constructor(v) {
        this.equals = (x) => {
            return this._content == x.toString();
        };
        this.toString = () => {
            return this._content;
        };
        /* TODO check value validity */
        this._content = v;
    }
    to_mich() {
        return {
            "bytes": this._content
        };
    }
    static from_mich(x) {
        return new Bls12_381_g2(x["bytes"]);
    }
}
exports.Bls12_381_g2 = Bls12_381_g2;
class Bytes {
    constructor(v) {
        this.equals = (x) => {
            return this._content == x.toString();
        };
        this.toString = () => {
            return this._content;
        };
        /**
         * Decodes hexadecimal bytes to string
         * @returns decoded string
         */
        this.hex_decode = () => {
            const output = Buffer.from(this._content, 'hex').toString();
            return output;
        };
        /* TODO check value validity */
        this._content = v;
    }
    to_mich() {
        return {
            "bytes": this._content
        };
    }
    static from_mich(x) {
        return new Bytes(x["bytes"]);
    }
    /**
     * Encode string to hexadecimal bytes
     * @param s string to encode
     * @returns new bytes object
     */
    static hex_encode(s) {
        const output = Buffer.from(s).toString('hex');
        return new Bytes(output);
    }
}
exports.Bytes = Bytes;
class Chain_id {
    constructor(v) {
        this.equals = (x) => {
            return this._content == x.toString();
        };
        this.toString = () => {
            return this._content;
        };
        this._content = is_base58_input_valid(v, chain_id_prefixes);
    }
    to_mich() {
        return {
            "string": this._content
        };
    }
    static from_mich(x) {
        if (x["bytes"]) {
            const input = x["bytes"];
            return new Chain_id(encode_prefix(prefixes.Net.prefix, input));
        }
        else {
            return new Chain_id(x["string"]);
        }
    }
}
exports.Chain_id = Chain_id;
class Chest {
    constructor(v) {
        this.equals = (x) => {
            return this._content == x.toString();
        };
        this.toString = () => {
            return this._content;
        };
        /* TODO check value validity */
        this._content = v;
    }
    to_mich() {
        return {
            "bytes": this._content
        };
    }
    static from_mich(x) {
        return new Chest(x["bytes"]);
    }
}
exports.Chest = Chest;
class Chest_key {
    constructor(v) {
        this.equals = (x) => {
            return this._content == x.toString();
        };
        this.toString = () => {
            return this._content;
        };
        /* TODO check value validity */
        this._content = v;
    }
    to_mich() {
        return {
            "bytes": this._content
        };
    }
    static from_mich(x) {
        return new Chest_key(x["bytes"]);
    }
}
exports.Chest_key = Chest_key;
class Duration {
    constructor(v) {
        this.DURATION_CONVERSION = {
            'w': 1 * 60 * 60 * 24 * 7,
            'd': 1 * 60 * 60 * 24,
            'h': 1 * 60 * 60,
            'm': 1 * 60,
            's': 1
        };
        this._content = this.convert_duration_literal_to_seconds(v);
    }
    to_mich() {
        return { "int": this._content.toString() };
    }
    static from_mich(x) {
        return new Duration(x["int"]);
    }
    equals(a) {
        return this._content.toString() == a.toString();
    }
    toString() {
        return this._content.toString();
    }
    toSecond() {
        return this._content;
    }
    is_duration_valid(input) {
        const pos_regexp = new RegExp(/(\d+[wdhms]){1,5}/);
        const pos_valid = input.match(pos_regexp);
        if (pos_valid && pos_valid[0] !== input)
            return false;
        return Object.keys(this.DURATION_CONVERSION).reduce((acc, key) => {
            const regexp = new RegExp(`\\d+${key}`);
            const ritem_value = input.match(regexp);
            return acc || ritem_value != null;
        }, false);
    }
    convert_duration_literal_to_seconds(input) {
        const regexpDigits = new RegExp(/^(-)?\d+$/);
        const valueDigits = input.match(regexpDigits);
        if (valueDigits != null) {
            return Number.parseInt(valueDigits[0], 10);
        }
        if (!this.is_duration_valid(input))
            throw new Error("Invalid duration input. Received input: `" + input + "' Try this format: '_w_d_h_m_s'.");
        return Object.entries(this.DURATION_CONVERSION).reduce((acc, [key, value]) => {
            let item_value = 0;
            const regexp = new RegExp(`\\d+${key}`);
            const ritem_value = input.match(regexp);
            if (ritem_value != null) {
                const v = ritem_value[0].slice(0, -1);
                item_value = Number.parseInt(v, 10);
            }
            return item_value * value + acc;
        }, 0);
    }
}
exports.Duration = Duration;
class Entrypoint {
    constructor(a, n) {
        this.to_mich = () => {
            return (0, exports.string_to_mich)(this.toString());
        };
        this.equals = (x) => {
            return this.addr == x.addr && this.name == x.name;
        };
        this.addr = a.toString();
        this.name = n;
    }
    toString() {
        return this.addr + '%' + this.name;
    }
    static from_mich(x) {
        const data = x["string"];
        if (data.indexOf("%") > 0) {
            const arr = data.split("%");
            return new Entrypoint(new Address(arr[0]), arr[1]);
        }
        else {
            return new Entrypoint(new Address(data), "default");
        }
    }
}
exports.Entrypoint = Entrypoint;
class Enum {
    constructor(_kind) {
        this._kind = _kind;
    }
    type() { return this._kind; }
}
exports.Enum = Enum;
class Int {
    constructor(v) {
        this.to_mich = () => {
            return { "int": this._content.toFixed() };
        };
        this.equals = (x) => {
            return this._content.isEqualTo(x.to_big_number());
        };
        this._content = new bignumber_js_1.BigNumber(v);
        if (this._content.comparedTo(this._content.integerValue()) != 0) {
            throw new Error("Not an Int value: " + v.toString());
        }
        else {
            this._content = new bignumber_js_1.BigNumber(v);
        }
    }
    static from_mich(x) {
        return new Int(x["int"]);
    }
    to_big_number() {
        return this._content;
    }
    to_number() {
        return this._content.toNumber();
    }
    plus(x) {
        return new Int(this._content.plus(x.to_big_number()));
    }
    minus(x) {
        return new Int(this._content.minus(x.to_big_number()));
    }
    times(x) {
        return new Int(this._content.times(x.to_big_number()));
    }
    div(x) {
        return this._content.div(x.to_big_number());
    }
    toString() {
        return this._content.toFixed();
    }
}
exports.Int = Int;
class Key {
    constructor(v) {
        this.equals = (x) => {
            return this._content == x.toString();
        };
        this.toString = () => {
            return this._content;
        };
        this._content = is_base58_input_valid(v, public_key_prefixes);
    }
    to_mich() {
        return {
            "string": this._content
        };
    }
    static from_mich(x) {
        if (x["bytes"]) {
            const input = x["bytes"];
            const first = input.substring(0, 2);
            const prefix = (() => {
                switch (first) {
                    case "00": return prefixes.edpk.prefix;
                    case "01": return prefixes.sppk.prefix;
                    case "02": return prefixes.p2pk.prefix;
                    default: throw new Error("Invalid input");
                }
            })();
            return new Key(encode_prefix(prefix, input.substring(2)));
        }
        else {
            return new Key(x["string"]);
        }
    }
}
exports.Key = Key;
class Key_hash {
    constructor(v) {
        this.equals = (x) => {
            return this._content == x.toString();
        };
        this.toString = () => {
            return this._content;
        };
        this._content = is_base58_input_valid(v, address_prefixes);
    }
    to_mich() {
        return (0, exports.string_to_mich)(this._content);
    }
    static from_mich(x) {
        if (x["bytes"]) {
            const input = x["bytes"];
            const [prefix, data] = extract_address_input(input);
            return new Key_hash(encode_prefix(prefix, data));
        }
        else {
            return new Key_hash(x["string"]);
        }
    }
}
exports.Key_hash = Key_hash;
class Nat {
    constructor(v) {
        this.to_mich = () => {
            return { "int": this._content.toFixed() };
        };
        this.equals = (x) => {
            return this._content.isEqualTo(x.to_big_number());
        };
        this.toString = () => {
            return this._content.toFixed();
        };
        this._content = new bignumber_js_1.BigNumber(v);
        if (this._content.comparedTo(this._content.integerValue()) != 0 || this._content.isLessThan(new bignumber_js_1.BigNumber(0))) {
            throw new Error("Not an Nat value: " + v.toString());
        }
    }
    static from_mich(x) {
        return new Nat(x["int"]);
    }
    to_big_number() {
        return this._content;
    }
    to_number() {
        return this._content.toNumber();
    }
    plus(x) {
        return new Nat(this._content.plus(x.to_big_number()));
    }
    minus(x) {
        return new Int(this._content.minus(x.to_big_number()));
    }
    times(x) {
        return new Nat(this._content.times(x.to_big_number()));
    }
    div(x) {
        return new Rational(this._content.div(x.to_big_number()));
    }
}
exports.Nat = Nat;
class Option {
    constructor(v) {
        this.get = () => {
            if (this._content != undefined && this._content != null) {
                return this._content;
            }
            else {
                throw new Error("Option.get : is none");
            }
        };
        this.to_mich = (f) => {
            if (this._content == undefined || this._content == null) {
                return exports.none_mich;
            }
            const mich = f(this._content);
            return (0, exports.some_to_mich)(mich);
        };
        this.equals = (o) => {
            return this.toString() == o.toString();
        };
        this.toString = () => {
            if (this._content == undefined || this._content == null) {
                return "None";
            }
            else {
                let str;
                switch (typeof this._content) {
                    case "string":
                        str = this._content;
                        break;
                    case "boolean":
                        str = this._content.toString();
                        break;
                    case "object": {
                        // js hack ...
                        if (this._content instanceof Date) {
                            const d = this._content;
                            str = d.toISOString();
                        }
                        else {
                            str = this._content.toString();
                        }
                        break;
                    }
                }
                return "Some (" + str + ")";
            }
        };
        this._content = v;
    }
    is_none() {
        return this._content == undefined || this._content == null;
    }
    is_some() {
        return this._content != undefined && this._content != null;
    }
    static from_mich(x, mich_to) {
        if ("prim" in x) {
            switch (x.prim) {
                case "None": return new Option(undefined);
                case "Some": return new Option(mich_to(x.args[0]));
            }
        }
        throw new Error("Option.from_mich: prim not found");
    }
}
exports.Option = Option;
Option.None = () => { return new Option(null); };
Option.Some = (v) => { return new Option(v); };
class Or {
    constructor(v, is_left) {
        this.get = () => {
            if (this._content != undefined && this._content != null) {
                return this._content;
            }
            else {
                throw new Error("Or.get : is not defined");
            }
        };
        this.equals = (o) => {
            return this.toString() == o.toString();
        };
        this._content = v;
        this._is_left = is_left;
    }
    is_left() { return this._is_left; }
    is_right() { return !this.is_left; }
    to_mich(f_left, f_right) {
        if (this.is_left()) {
            const c_left = this._content;
            const mich = f_left(c_left);
            return (0, exports.left_to_mich)(mich);
        }
        else {
            const c_right = this._content;
            const mich = f_right(c_right);
            return (0, exports.right_to_mich)(mich);
        }
    }
    static from_mich(x, mich_to_left, mich_to_right) {
        const p = x;
        if (p.prim == "Left") {
            return Or.Left(mich_to_left(p.args[0]));
        }
        if (p.prim == "Right") {
            return Or.Right(mich_to_right(p.args[0]));
        }
        throw new Error(`Or.from_mich: Invalid prim ${p.prim}`);
    }
    toString() {
        let str;
        switch (typeof this._content) {
            case "string":
                str = this._content;
                break;
            case "boolean":
                str = this._content.toString();
                break;
            case "object":
                // js hack ...
                if (this._content instanceof Date) {
                    const d = this._content;
                    str = d.toISOString();
                }
                else {
                    str = this._content.toString();
                }
        }
        if (this.is_left()) {
            return "Left (" + str + ")";
        }
        else {
            return "Right (" + str + ")";
        }
    }
}
exports.Or = Or;
Or.Left = (v) => { return new Or(v, true); };
Or.Right = (v) => { return new Or(v, false); };
class Rational {
    constructor(v, denom = new bignumber_js_1.BigNumber(1)) {
        this.extract_number = (input) => {
            switch (typeof input) {
                case "string": {
                    const parsed = input.endsWith('%') ? parseFloat(input) / 100 : input;
                    if (null !== parsed && !Number.isNaN(parsed)) {
                        return new bignumber_js_1.BigNumber(parsed);
                    }
                    else {
                        throw new Error("Rational error: '" + input + "' not a number");
                    }
                }
            }
            return new bignumber_js_1.BigNumber(input);
        };
        this.to_mich = () => {
            const [num, denom] = this._content.toFraction();
            return {
                prim: "Pair",
                args: [
                    { "int": num.toFixed() },
                    { "int": denom.toFixed() }
                ]
            };
        };
        this.equals = (x) => {
            return this._content.isEqualTo(x.to_big_number());
        };
        this.toString = () => {
            return this._content.toFixed();
        };
        const numerator = this.extract_number(v);
        const denominator = this.extract_number(denom);
        this._content = numerator.div(denominator);
    }
    static from_mich(x) {
        const numerator = new bignumber_js_1.BigNumber(x.args[0]["int"]);
        const denominator = new bignumber_js_1.BigNumber(x.args[1]["int"]);
        return new Rational(numerator.dividedBy(denominator));
    }
    to_big_number() {
        return this._content;
    }
    to_number() {
        return this._content.toNumber();
    }
    plus(x) {
        return new Rational(this._content.plus(x.to_big_number()));
    }
    minus(x) {
        return new Rational(this._content.minus(x.to_big_number()));
    }
    times(x) {
        return new Rational(this._content.times(x.to_big_number()));
    }
    div(x) {
        return new Rational(this._content.div(x.to_big_number()));
    }
    floor() {
        return new Int(this._content.integerValue(bignumber_js_1.BigNumber.ROUND_FLOOR));
    }
    ceil() {
        return new Int(this._content.integerValue(bignumber_js_1.BigNumber.ROUND_CEIL));
    }
}
exports.Rational = Rational;
class Sapling_state {
    constructor(v) {
        this.equals = (x) => {
            return this._content == x.toString();
        };
        this.toString = () => {
            return this._content;
        };
        /* TODO check value validity */
        this._content = v;
    }
    to_mich() {
        return {
            "int": this._content
        };
    }
    static from_mich(x) {
        return new Sapling_state(x["int"]);
    }
}
exports.Sapling_state = Sapling_state;
class Sapling_transaction {
    constructor(v) {
        this.equals = (x) => {
            return this._content == x.toString();
        };
        this.toString = () => {
            return this._content;
        };
        /* TODO check value validity */
        this._content = v;
    }
    to_mich() {
        return {
            "bytes": this._content
        };
    }
    static from_mich(x) {
        return new Sapling_transaction(x["bytes"]);
    }
}
exports.Sapling_transaction = Sapling_transaction;
class Signature {
    constructor(v) {
        this.equals = (x) => {
            return this._content == x.toString();
        };
        this.toString = () => {
            return this._content;
        };
        this._content = is_base58_input_valid(v, signature_prefixes);
    }
    to_mich() {
        return {
            "string": this._content
        };
    }
    static from_mich(x) {
        if (x["bytes"]) {
            const input = x["bytes"];
            return new Signature(encode_prefix(prefixes.sig.prefix, input));
        }
        else {
            return new Signature(x["string"]);
        }
    }
    normalize() {
        if (this._content.startsWith("sig")) {
            return this._content;
        }
        const prefix = this._content.substring(0, 5);
        const start = (() => {
            switch (prefix) {
                case "edsig": return 5;
                case "spsig": return 5;
                case "p2sig": return 4;
                default: throw new Error("Internal error");
            }
        })();
        const data = bs58check_1.default.decodeUnsafe(this._content);
        if (data === undefined) {
            throw new Error("Internal error");
        }
        return bs58check_1.default.encode(Buffer.concat([hexStringToBuffer(escapeSequenceToHexString(signature_prefixes.sig.prefix)), data.subarray(start)]));
    }
}
exports.Signature = Signature;
class Tez {
    constructor(v, unit = "tez") {
        this.to_mich = () => {
            return { "int": this.toString() };
        };
        this.equals = (x) => {
            return this._content.isEqualTo(x.to_big_number());
        };
        this.toString = (unit = "mutez") => {
            if (unit == "tez")
                return this._content.div(1000000).toFixed();
            return this._content.toFixed();
        };
        this._content = new bignumber_js_1.BigNumber(v);
        switch (unit) {
            case "mutez":
                if (this._content.comparedTo(this._content.integerValue()) != 0)
                    throw new Error("Mutez value must be integer");
                break;
            case "tez":
                if (this._content.isLessThan(new bignumber_js_1.BigNumber(0)))
                    throw new Error("Tez value must not be negative");
                if (this._content.isGreaterThan(new bignumber_js_1.BigNumber("")) || this._content.isNaN())
                    throw new Error("Invalid Tez value");
                this._content = new bignumber_js_1.BigNumber(this._content.times(1000000).integerValue(bignumber_js_1.BigNumber.ROUND_FLOOR));
        }
    }
    static from_mich(x) {
        return new Tez(x["int"], "mutez");
    }
    to_big_number() {
        return this._content;
    }
    plus(x) {
        return new Tez(this._content.plus(x.to_big_number()), "mutez");
    }
    minus(x) {
        return new Tez(this._content.minus(x.to_big_number()), "mutez");
    }
    times(x) {
        return new Tez(this._content.times(x.to_big_number()), "mutez");
    }
}
exports.Tez = Tez;
class Ticket {
    constructor(ticketer, contents, amount) {
        this.get_ticketer = () => { return this.ticketer; };
        this.get_contents = () => { return this.contents; };
        this.get_amount = () => { return this.amount; };
        this.to_mich = (f) => {
            const arg_ticketer = { "string": this.ticketer.toString() };
            const arg_contents = f(this.contents);
            const arg_amount = { "int": this.amount.toString() };
            return { prim: "Pair", args: [arg_ticketer, arg_contents, arg_amount] };
        };
        this.equals = (t) => {
            return this.toString() == t.toString();
        };
        this.toString = () => {
            return `(${this.ticketer.toString()}, ${this.contents.toString()}, ${this.amount.toString()})`;
        };
        this.ticketer = ticketer;
        this.contents = contents;
        this.amount = amount;
    }
    static from_mich(x, mich_to) {
        const source = new Address(x.args[0]["string"]);
        const value = mich_to(x.args[1]);
        const amount = new Nat(x.args[2]["int"]);
        return new Ticket(source, value, amount);
    }
}
exports.Ticket = Ticket;
class Unit {
    constructor() {
        this.equals = (x) => {
            return true;
        };
        this.toString = () => {
            return "Unit";
        };
    }
    to_mich() {
        return {
            "prim": "Unit"
        };
    }
    static from_mich(x) {
        return new Unit();
    }
}
exports.Unit = Unit;
/* to Micheline ------------------------------------------------------------ */
const prim_to_mich_type = (p) => {
    return {
        prim: p,
        annots: []
    };
};
exports.prim_to_mich_type = prim_to_mich_type;
const prim_annot_to_mich_type = (p, a) => {
    return {
        prim: p,
        annots: a
    };
};
exports.prim_annot_to_mich_type = prim_annot_to_mich_type;
exports.unit_mich = { prim: "Unit" };
const unit_to_mich = () => {
    return exports.unit_mich;
};
exports.unit_to_mich = unit_to_mich;
const string_to_mich = (v) => {
    return { "string": v };
};
exports.string_to_mich = string_to_mich;
const bool_to_mich = (v) => {
    return v ? { "prim": "True" } : { "prim": "False" };
};
exports.bool_to_mich = bool_to_mich;
const date_to_mich = (v) => {
    return { "int": Math.floor(v.getTime() / 1000).toString() };
};
exports.date_to_mich = date_to_mich;
const elt_to_mich = (a, b) => {
    return {
        prim: "Elt",
        args: [a, b]
    };
};
exports.elt_to_mich = elt_to_mich;
const left_to_mich = (v) => {
    return {
        prim: "Left",
        args: [v]
    };
};
exports.left_to_mich = left_to_mich;
const right_to_mich = (v) => {
    return {
        prim: "Right",
        args: [v]
    };
};
exports.right_to_mich = right_to_mich;
const or_to_mich_type = (l, r, a = []) => {
    return {
        prim: "or",
        args: [l, r],
        annots: a
    };
};
exports.or_to_mich_type = or_to_mich_type;
const pair_to_mich = (l) => {
    return {
        prim: "Pair",
        args: l
    };
};
exports.pair_to_mich = pair_to_mich;
const pair_to_mich_type = (prim, a, b) => {
    return {
        prim: prim,
        args: [a, b],
        annots: []
    };
};
exports.pair_to_mich_type = pair_to_mich_type;
const pair_annot_to_mich_type = (prim, a, b, annots) => {
    return {
        prim: prim,
        args: [a, b],
        annots: annots
    };
};
exports.pair_annot_to_mich_type = pair_annot_to_mich_type;
const pair_array_to_mich_type = (l, annots = []) => {
    return {
        prim: "pair",
        args: l,
        annots: annots
    };
};
exports.pair_array_to_mich_type = pair_array_to_mich_type;
const mich_array_to_mich = (l) => {
    if (l.length == 1) {
        return l[0];
    }
    if (l.length == 2) {
        return (0, exports.pair_to_mich)(l);
    }
    else {
        return (0, exports.pair_to_mich)([l[0], (0, exports.mich_array_to_mich)(l.slice(1))]);
    }
};
exports.mich_array_to_mich = mich_array_to_mich;
const contract_to_mich_type = (a) => {
    return {
        prim: "contract",
        args: [a],
        annots: []
    };
};
exports.contract_to_mich_type = contract_to_mich_type;
const contract_annot_to_mich_type = (mt, a) => {
    return {
        prim: "contract",
        args: [mt],
        annots: a
    };
};
exports.contract_annot_to_mich_type = contract_annot_to_mich_type;
const option_to_mich_type = (a) => {
    return {
        prim: "option",
        args: [a],
        annots: []
    };
};
exports.option_to_mich_type = option_to_mich_type;
const option_annot_to_mich_type = (mt, a) => {
    return {
        prim: "option",
        args: [mt],
        annots: a
    };
};
exports.option_annot_to_mich_type = option_annot_to_mich_type;
const ticket_to_mich_type = (a) => {
    return {
        prim: "ticket",
        args: [a],
        annots: []
    };
};
exports.ticket_to_mich_type = ticket_to_mich_type;
const ticket_annot_to_mich_type = (mt, a) => {
    return {
        prim: "ticket",
        args: [mt],
        annots: a
    };
};
exports.ticket_annot_to_mich_type = ticket_annot_to_mich_type;
const list_to_mich = (l, to_mich) => {
    return l.map(x => to_mich(x));
};
exports.list_to_mich = list_to_mich;
const list_to_mich_type = (mt) => {
    return {
        prim: "list",
        args: [mt],
        annots: []
    };
};
exports.list_to_mich_type = list_to_mich_type;
const list_annot_to_mich_type = (mt, a) => {
    return {
        prim: "list",
        args: [mt],
        annots: a
    };
};
exports.list_annot_to_mich_type = list_annot_to_mich_type;
const set_to_mich_type = (mt) => {
    return {
        prim: "set",
        args: [mt],
        annots: []
    };
};
exports.set_to_mich_type = set_to_mich_type;
const set_annot_to_mich_type = (mt, a) => {
    return {
        prim: "set",
        args: [mt],
        annots: a
    };
};
exports.set_annot_to_mich_type = set_annot_to_mich_type;
const set_to_mich = (s, to_json) => {
    Array.from(s.values()).map(x => to_json(x));
};
exports.set_to_mich = set_to_mich;
const string_cmp = (a, b) => {
    if (a === b) {
        return 0;
    }
    return a < b ? -1 : 1;
};
exports.string_cmp = string_cmp;
const date_cmp = (a, b) => {
    return (a.getTime() - a.getMilliseconds()) == (b.getTime() - b.getMilliseconds());
};
exports.date_cmp = date_cmp;
const mich_to_pairs = (x) => {
    return x["args"];
};
exports.mich_to_pairs = mich_to_pairs;
const annotated_mich_to_array = (x, t) => {
    const internal_mich_to_array = (x, t, acc) => {
        if (t.annots && t.annots.length > 0) {
            acc.push(x);
            return acc;
        }
        else {
            switch (t.prim) {
                case "pair": {
                    const pair = x;
                    return (pair.args.reduce((a, x, i) => {
                        return internal_mich_to_array(x, t.args[i], a);
                    }, acc));
                }
                default: throw new Error("internal_mich_to_array: found an unannotated node that is not a pair but a '" + t.prim + "'");
            }
        }
    };
    return internal_mich_to_array(x, t, []);
};
exports.annotated_mich_to_array = annotated_mich_to_array;
const mich_to_string = (x) => {
    return x["string"];
};
exports.mich_to_string = mich_to_string;
const mich_to_date = (x) => {
    return new Date(x["string"]);
};
exports.mich_to_date = mich_to_date;
const mich_to_bool = (x) => {
    switch (x.prim) {
        case "False": return false;
        case "True": return true;
        default: throw new Error("mich_to_bool: invalid prim '" + x.prim + "'");
    }
};
exports.mich_to_bool = mich_to_bool;
const mich_to_list = (x, mich_to) => {
    const xlist = x;
    return xlist.map(mich_to);
};
exports.mich_to_list = mich_to_list;
const mich_to_map = (x, f) => {
    return x.map((elt) => {
        const k = elt["args"][0];
        const v = elt["args"][1];
        return f(k, v);
    });
};
exports.mich_to_map = mich_to_map;
const is_left = (x) => {
    return x["prim"] == "Left";
};
exports.is_left = is_left;
const is_right = (x) => {
    return x["prim"] == "Right";
};
exports.is_right = is_right;
const replace_var = (x, params) => {
    const convert_const = (x) => { return `const_${x}__`; };
    const aux = (x) => {
        if (x.var) {
            const id = x.var;
            const v = params.reduce((accu, x) => {
                if (x[0] == id || convert_const(x[0]) == id) {
                    return x[1];
                }
                else {
                    return accu;
                }
            }, null);
            if (v == null) {
                throw (`Error: cannot replace var ${id} in replace_var`);
            }
            return v;
        }
        if (x.args) {
            const new_args = x.args.map(x => (0, exports.replace_var)(x, params));
            return Object.assign(Object.assign({}, x), { args: new_args });
        }
        if (x && x.length > 0) {
            return x.map(x => (0, exports.replace_var)(x, params));
        }
        else {
            return x;
        }
    };
    return aux(x);
};
exports.replace_var = replace_var;
const normalize = (input) => {
    if (isPrimWithArgs(input)) {
        const args = input.args.map(exports.normalize);
        if (args.length > 0) {
            const last = args[args.length - 1];
            if (isPrimWithArgs(last) && last.prim === 'Pair') {
                return Object.assign(Object.assign({}, input), { args: [...args.slice(0, -1), ...last.args] });
            }
        }
        return Object.assign(Object.assign({}, input), { args });
    }
    else if (isArray(input)) {
        return input.map(exports.normalize);
    }
    return input;
};
exports.normalize = normalize;
function isPrimWithArgs(input) {
    return typeof input === 'object' && input !== null && 'prim' in input && input.prim === 'Pair' && 'args' in input;
}
function isArray(input) {
    return Array.isArray(input);
}
//# sourceMappingURL=main.js.map
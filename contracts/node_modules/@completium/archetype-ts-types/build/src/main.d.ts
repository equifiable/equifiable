import { BigNumber } from 'bignumber.js';
export declare type MTprim = {
    "prim": "address" | "bls12_381_fr" | "bls12_381_g1" | "bls12_381_g2" | "bool" | "bytes" | "chain_id" | "chest" | "chest_key" | "int" | "key" | "key_hash" | "mutez" | "nat" | "never" | "operation" | "signature" | "string" | "timestamp" | "unit";
    "annots"?: Array<string>;
};
export declare type MTsingle = {
    "prim": "contract" | "list" | "option" | "set" | "ticket";
    "args": [MichelineType];
    "annots"?: Array<string>;
};
export declare type MTint = {
    "prim": "sapling_transaction" | "sapling_state";
    "args": [
        {
            "int": string;
        }
    ];
    "annots"?: Array<string>;
};
export declare type MTPairArray = {
    "prim": "pair";
    "args": Array<MichelineType>;
    "annots"?: Array<string>;
};
export declare type MTpair = {
    "prim": "big_map" | "lambda" | "map" | "or";
    "args": [MichelineType, MichelineType];
    "annots"?: Array<string>;
};
export declare type MichelineType = MTprim | MTsingle | MTint | MTpair | MTPairArray;
export declare type Mprim = {
    "prim": "True" | "False" | "None" | "Unit";
};
export declare type Mstring = {
    "string": string;
};
export declare type Mbytes = {
    "bytes": string;
};
export declare type Mint = {
    "int": string;
};
export declare type Mpair = {
    "prim": "Pair";
    "args": Array<Micheline>;
};
export declare type Melt = {
    "prim": "Elt";
    "args": [Micheline, Micheline];
};
export declare type Msingle = {
    "prim": "Some" | "Right" | "Left" | "Lambda_rec";
    "args": [Micheline];
};
export declare type MMichelineInstr = {
    "prim": "PACK" | "UNPACK" | "BLAKE2B" | "SHA256" | "SHA512" | "ABS" | "ADD" | "AMOUNT" | "AND" | "BALANCE" | "CAR" | "CDR" | "CHAIN_ID" | "CHECK_SIGNATURE" | "COMPARE" | "CONCAT" | "CONS" | "CREATE_ACCOUNT" | "CREATE_CONTRACT" | "IMPLICIT_ACCOUNT" | "DIP" | "DROP" | "DUP" | "VIEW" | "EDIV" | "EMPTY_BIG_MAP" | "EMPTY_MAP" | "EMPTY_SET" | "EQ" | "EXEC" | "APPLY" | "FAILWITH" | "GE" | "GET" | "GET_AND_UPDATE" | "GT" | "HASH_KEY" | "IF" | "IF_CONS" | "IF_LEFT" | "IF_NONE" | "INT" | "LAMBDA" | "LAMBDA_REC" | "LE" | "LEFT" | "LEVEL" | "LOOP" | "LSL" | "LSR" | "LT" | "MAP" | "MEM" | "MUL" | "NEG" | "NEQ" | "NIL" | "NONE" | "NOT" | "NOW" | "MIN_BLOCK_TIME" | "OR" | "PAIR" | "UNPAIR" | "PUSH" | "RIGHT" | "SIZE" | "SOME" | "SOURCE" | "SENDER" | "SELF" | "SELF_ADDRESS" | "SLICE" | "STEPS_TO_QUOTA" | "SUB" | "SUB_MUTEZ" | "SWAP" | "TRANSFER_TOKENS" | "SET_DELEGATE" | "UNIT" | "UPDATE" | "XOR" | "ITER" | "LOOP_LEFT" | "ADDRESS" | "CONTRACT" | "ISNAT" | "CAST" | "RENAME" | "SAPLING_EMPTY_STATE" | "SAPLING_VERIFY_UPDATE" | "DIG" | "DUG" | "NEVER" | "VOTING_POWER" | "TOTAL_VOTING_POWER" | "KECCAK" | "SHA3" | "PAIRING_CHECK" | "TICKET" | "TICKET_DEPRECATED" | "READ_TICKET" | "SPLIT_TICKET" | "JOIN_TICKETS" | "OPEN_CHEST" | "EMIT" | "BYTES";
    "args"?: Array<Micheline>;
    "annots"?: Array<string>;
};
export declare type MMichelineKeyword = {
    "prim": "parameter" | "storage" | "code" | "view";
    "args"?: Array<Micheline>;
    "annots"?: Array<string>;
};
export declare type MMichelineConstantHash = {
    "prim": "constant";
    "args"?: Array<Micheline>;
    "annots"?: Array<string>;
};
export declare type Marray = Array<Micheline>;
export declare type Micheline = Mprim | Mstring | Mbytes | Mint | Msingle | Mpair | Melt | Marray | MichelineType | MMichelineInstr | MMichelineKeyword | MMichelineConstantHash;
export declare type ArchetypeTypeArg = ArchetypeType | Array<ArchetypeTypeArg> | string | Date | boolean;
export interface DeployResult {
    address: string;
}
export interface OriginateResult {
    address: string;
}
export interface EventData {
    from: Address;
    type: MichelineType;
    tag: string;
    payload: Micheline;
    consumed_gas: number;
}
export interface CallResult {
    operation_hash: string;
    storage_size: number;
    consumed_gas: number;
    paid_storage_size_diff: number;
    events: Array<EventData>;
}
export interface BatchResult {
    events: Array<EventData>;
    dummy: number;
}
export interface GetterResult {
    value: any;
    events: Array<EventData>;
    dummy: number;
}
export interface ViewResult {
    value: any;
    dummy: number;
}
export interface TransferResult {
    dummy: number;
}
export interface CallParameter {
    destination: Address;
    amount: Tez;
    fee?: Tez;
    entrypoint: string;
    arg: Micheline;
}
export declare abstract class ArchetypeType {
    abstract toString(): string;
}
export declare const none_mich: Micheline;
export declare const some_to_mich: (a: Micheline) => Micheline;
export declare const micheline_equals: (lhs: Micheline, rhs: Micheline) => boolean;
export declare const list_equals: <T>(l1: T[], l2: T[], cmp: (e1: T, e2: T) => boolean) => boolean;
export declare const getter_args_to_mich: (arg: Micheline, callback: Entrypoint) => Micheline;
export declare class Address implements ArchetypeType {
    private _content;
    constructor(v: string);
    to_mich(): Micheline;
    static from_mich(x: Micheline): Address;
    equals(a: Address): boolean;
    toString(): string;
}
export declare class Bls12_381_fr implements ArchetypeType {
    private _content;
    constructor(v: string);
    to_mich(): Micheline;
    static from_mich(x: Micheline): Bls12_381_fr;
    equals: (x: Bls12_381_fr) => boolean;
    toString: () => string;
}
export declare class Bls12_381_g1 implements ArchetypeType {
    private _content;
    constructor(v: string);
    to_mich(): Micheline;
    static from_mich(x: Micheline): Bls12_381_g1;
    equals: (x: Bls12_381_g1) => boolean;
    toString: () => string;
}
export declare class Bls12_381_g2 implements ArchetypeType {
    private _content;
    constructor(v: string);
    to_mich(): Micheline;
    static from_mich(x: Micheline): Bls12_381_g2;
    equals: (x: Bls12_381_g2) => boolean;
    toString: () => string;
}
export declare class Bytes implements ArchetypeType {
    private _content;
    constructor(v: string);
    to_mich(): Micheline;
    static from_mich(x: Micheline): Bytes;
    equals: (x: Bytes) => boolean;
    toString: () => string;
    /**
     * Encode string to hexadecimal bytes
     * @param s string to encode
     * @returns new bytes object
     */
    static hex_encode(s: string): Bytes;
    /**
     * Decodes hexadecimal bytes to string
     * @returns decoded string
     */
    hex_decode: () => string;
}
export declare class Chain_id implements ArchetypeType {
    private _content;
    constructor(v: string);
    to_mich(): Micheline;
    static from_mich(x: Micheline): Chain_id;
    equals: (x: Chain_id) => boolean;
    toString: () => string;
}
export declare class Chest implements ArchetypeType {
    private _content;
    constructor(v: string);
    to_mich(): Micheline;
    static from_mich(x: Micheline): Chest;
    equals: (x: Chest) => boolean;
    toString: () => string;
}
export declare class Chest_key implements ArchetypeType {
    private _content;
    constructor(v: string);
    to_mich(): Micheline;
    static from_mich(x: Micheline): Chest_key;
    equals: (x: Chest_key) => boolean;
    toString: () => string;
}
export declare class Duration implements ArchetypeType {
    private _content;
    constructor(v: string);
    to_mich(): Micheline;
    static from_mich(x: Micheline): Duration;
    equals(a: Duration): boolean;
    toString(): string;
    toSecond(): number;
    private DURATION_CONVERSION;
    private is_duration_valid;
    private convert_duration_literal_to_seconds;
}
export declare class Entrypoint implements ArchetypeType {
    addr: string;
    name: string;
    constructor(a: Address, n: string);
    to_mich: () => Micheline;
    equals: (x: Entrypoint) => boolean;
    toString(): string;
    static from_mich(x: Micheline): Entrypoint;
}
export declare abstract class Enum<T> implements ArchetypeType {
    private _kind;
    constructor(_kind: T);
    type(): T;
    abstract to_mich(): Micheline;
    abstract toString(): string;
}
export declare class Int implements ArchetypeType {
    private _content;
    constructor(v: string | number | BigNumber);
    to_mich: () => Micheline;
    static from_mich(x: Micheline): Int;
    to_big_number(): BigNumber;
    to_number(): number;
    plus(x: Int): Int;
    minus(x: Int): Int;
    times(x: Int): Int;
    div(x: Int): BigNumber;
    equals: (x: Int) => boolean;
    toString(): string;
}
export declare class Key implements ArchetypeType {
    private _content;
    constructor(v: string);
    to_mich(): Micheline;
    static from_mich(x: Micheline): Key;
    equals: (x: Key) => boolean;
    toString: () => string;
}
export declare class Key_hash implements ArchetypeType {
    private _content;
    constructor(v: string);
    to_mich(): Micheline;
    static from_mich(x: Micheline): Key_hash;
    equals: (x: Key_hash) => boolean;
    toString: () => string;
}
export declare class Nat implements ArchetypeType {
    private _content;
    constructor(v: string | number | BigNumber);
    to_mich: () => Micheline;
    static from_mich(x: Micheline): Nat;
    to_big_number(): BigNumber;
    to_number(): number;
    plus(x: Nat): Nat;
    minus(x: Nat): Int;
    times(x: Nat): Nat;
    div(x: Nat): Rational;
    equals: (x: Nat) => boolean;
    toString: () => string;
}
export declare class Option<T extends ArchetypeTypeArg> implements ArchetypeType {
    _content: T | undefined | null;
    constructor(v: T | undefined | null);
    static None: <T_1 extends ArchetypeTypeArg>() => Option<T_1>;
    static Some: <T_1 extends ArchetypeTypeArg>(v: T_1) => Option<T_1>;
    get: () => T;
    is_none(): boolean;
    is_some(): boolean;
    to_mich: (f: (_: T) => Micheline) => Micheline;
    static from_mich<T extends ArchetypeTypeArg>(x: Micheline, mich_to: (_: any) => T): Option<T>;
    equals: (o: Option<T>) => boolean;
    toString: () => string;
}
export declare class Or<T1 extends ArchetypeTypeArg, T2 extends ArchetypeTypeArg> implements ArchetypeType {
    _content: T1 | T2;
    _is_left: boolean;
    constructor(v: T1 | T2, is_left: boolean);
    static Left: <T1_1 extends ArchetypeTypeArg, T2_1 extends ArchetypeTypeArg>(v: T1_1) => Or<T1_1, T2_1>;
    static Right: <T1_1 extends ArchetypeTypeArg, T2_1 extends ArchetypeTypeArg>(v: T2_1) => Or<T1_1, T2_1>;
    get: () => T1 | T2;
    is_left(): boolean;
    is_right(): boolean;
    to_mich(f_left: ((_: T1) => Micheline), f_right: ((_: T2) => Micheline)): Micheline;
    static from_mich<T1 extends ArchetypeType, T2 extends ArchetypeType>(x: Micheline, mich_to_left: ((_: Micheline) => T1), mich_to_right: ((_: Micheline) => T2)): Or<T1, T2>;
    toString(): string;
    equals: (o: Or<T1, T2>) => boolean;
}
export declare class Rational implements ArchetypeType {
    private _content;
    extract_number: (input: string | number | BigNumber) => BigNumber;
    constructor(v: string | number | BigNumber, denom?: string | number | BigNumber);
    to_mich: () => Micheline;
    static from_mich(x: Micheline): Rational;
    to_big_number(): BigNumber;
    to_number(): number;
    plus(x: Rational): Rational;
    minus(x: Rational): Rational;
    times(x: Rational): Rational;
    div(x: Rational): Rational;
    floor(): Int;
    ceil(): Int;
    equals: (x: Rational) => boolean;
    toString: () => string;
}
export declare class Sapling_state implements ArchetypeType {
    private _content;
    constructor(v: string);
    to_mich(): Micheline;
    static from_mich(x: Micheline): Sapling_state;
    equals: (x: Sapling_state) => boolean;
    toString: () => string;
}
export declare class Sapling_transaction implements ArchetypeType {
    private _content;
    constructor(v: string);
    to_mich(): Micheline;
    static from_mich(x: Micheline): Sapling_transaction;
    equals: (x: Sapling_transaction) => boolean;
    toString: () => string;
}
export declare class Signature implements ArchetypeType {
    private _content;
    constructor(v: string);
    to_mich(): Micheline;
    static from_mich(x: Micheline): Signature;
    equals: (x: Signature) => boolean;
    toString: () => string;
    normalize(): string;
}
export declare class Tez implements ArchetypeType {
    private _content;
    constructor(v: string | number | BigNumber, unit?: "tez" | "mutez");
    to_mich: () => Micheline;
    static from_mich(x: Micheline): Tez;
    to_big_number(): BigNumber;
    plus(x: Tez): Tez;
    minus(x: Tez): Tez;
    times(x: Nat): Tez;
    equals: (x: Tez) => boolean;
    toString: (unit?: "tez" | "mutez") => string;
}
export declare class Ticket<T extends ArchetypeTypeArg> implements ArchetypeType {
    ticketer: Address;
    contents: T;
    amount: Nat;
    constructor(ticketer: Address, contents: T, amount: Nat);
    get_ticketer: () => Address;
    get_contents: () => T;
    get_amount: () => Nat;
    to_mich: (f: (_: T) => Micheline) => Micheline;
    static from_mich<T extends ArchetypeType>(x: Micheline, mich_to: (_: Micheline) => T): Ticket<T>;
    equals: (t: Ticket<T>) => boolean;
    toString: () => string;
}
export declare class Unit implements ArchetypeType {
    to_mich(): Micheline;
    static from_mich(x: Micheline): Unit;
    equals: (x: Unit) => boolean;
    toString: () => string;
}
export declare const prim_to_mich_type: (p: "address" | "bls12_381_fr" | "bls12_381_g1" | "bls12_381_g2" | "bool" | "bytes" | "chain_id" | "chest" | "chest_key" | "int" | "key" | "key_hash" | "mutez" | "nat" | "never" | "operation" | "signature" | "string" | "timestamp" | "unit") => MichelineType;
export declare const prim_annot_to_mich_type: (p: "address" | "bls12_381_fr" | "bls12_381_g1" | "bls12_381_g2" | "bool" | "bytes" | "chain_id" | "chest" | "chest_key" | "int" | "key" | "key_hash" | "mutez" | "nat" | "never" | "operation" | "signature" | "string" | "timestamp" | "unit", a: Array<string>) => MichelineType;
export declare const unit_mich: Micheline;
export declare const unit_to_mich: () => Micheline;
export declare const string_to_mich: (v: string) => Micheline;
export declare const bool_to_mich: (v: boolean) => Micheline;
export declare const date_to_mich: (v: Date) => Micheline;
export declare const elt_to_mich: (a: Micheline, b: Micheline) => Micheline;
export declare const left_to_mich: (v: Micheline) => Micheline;
export declare const right_to_mich: (v: Micheline) => Micheline;
export declare const or_to_mich_type: (l: MichelineType, r: MichelineType, a?: string[]) => MichelineType;
export declare const pair_to_mich: (l: Array<Micheline>) => Micheline;
export declare const pair_to_mich_type: (prim: "big_map" | "lambda" | "map" | "or", a: MichelineType, b: MichelineType) => MichelineType;
export declare const pair_annot_to_mich_type: (prim: "big_map" | "lambda" | "map" | "or", a: MichelineType, b: MichelineType, annots: Array<string>) => MichelineType;
export declare const pair_array_to_mich_type: (l: Array<MichelineType>, annots?: Array<string>) => MichelineType;
export declare const mich_array_to_mich: (l: Array<Micheline>) => Micheline;
export declare const contract_to_mich_type: (a: MichelineType) => MichelineType;
export declare const contract_annot_to_mich_type: (mt: MichelineType, a: Array<string>) => MichelineType;
export declare const option_to_mich_type: (a: MichelineType) => MichelineType;
export declare const option_annot_to_mich_type: (mt: MichelineType, a: Array<string>) => MichelineType;
export declare const ticket_to_mich_type: (a: MichelineType) => MichelineType;
export declare const ticket_annot_to_mich_type: (mt: MichelineType, a: Array<string>) => MichelineType;
export declare const list_to_mich: <T>(l: T[], to_mich: (a: T) => Micheline) => Micheline;
export declare const list_to_mich_type: (mt: MichelineType) => MichelineType;
export declare const list_annot_to_mich_type: (mt: MichelineType, a: Array<string>) => MichelineType;
export declare const set_to_mich_type: (mt: MichelineType) => MichelineType;
export declare const set_annot_to_mich_type: (mt: MichelineType, a: Array<string>) => MichelineType;
export declare const set_to_mich: <T>(s: Set<T>, to_json: (a: T) => Micheline) => void;
export declare const string_cmp: (a: string, b: string) => 0 | 1 | -1;
export declare const date_cmp: (a: Date, b: Date) => boolean;
export declare const mich_to_pairs: (x: Micheline) => Array<Micheline>;
export declare const annotated_mich_to_array: (x: Micheline, t: MichelineType) => Array<Micheline>;
export declare const mich_to_string: (x: Micheline) => string;
export declare const mich_to_date: (x: Micheline) => Date;
export declare const mich_to_bool: (x: Micheline) => boolean;
export declare const mich_to_list: <T>(x: Micheline, mich_to: (_: Micheline) => T) => T[];
export declare const mich_to_map: <K, V>(x: Micheline, f: (k: Micheline, v: Micheline) => [K, V]) => [K, V][];
export declare const is_left: (x: Micheline) => boolean;
export declare const is_right: (x: Micheline) => boolean;
export declare type UnsafeMicheline = {
    prim: string;
    annots?: Array<string>;
    args?: Array<UnsafeMicheline>;
} | {
    string: string;
} | {
    int: string;
} | {
    bytes: string;
} | {
    var: string;
} | Array<UnsafeMicheline>;
export declare const replace_var: (x: UnsafeMicheline, params: Array<[string, Micheline]>) => Micheline;
export declare const normalize: (input: UnsafeMicheline) => UnsafeMicheline;
//# sourceMappingURL=main.d.ts.map
import ts, { KeywordTypeNode } from "typescript";
export declare type ATSimple = {
    node: "address" | "bls12_381_fr" | "bls12_381_g1" | "bls12_381_g2" | "bool" | "bytes" | "chain_id" | "chest_key" | "chest" | "currency" | "date" | "duration" | "int" | "key_hash" | "key" | "nat" | "never" | "operation" | "rational" | "signature" | "state" | "string" | "timestamp" | "unit";
};
export declare type ATSapling = {
    node: "sapling_state" | "sapling_transaction";
    memo_size: number;
};
export declare type ATNamed = {
    node: "aggregate" | "asset_container" | "asset_key" | "asset_value" | "asset_view" | "asset" | "collection" | "enum" | "event" | "partition" | "record";
    name: string;
};
export declare type ATSingle = {
    node: "contract" | "list" | "option" | "set" | "ticket";
    arg: ArchetypeType;
};
export declare type ATMap = {
    node: "big_map" | "iterable_big_map" | "map";
    key_type: ArchetypeType;
    value_type: ArchetypeType;
};
export declare type ATOr = {
    node: "or";
    left_type: ArchetypeType;
    right_type: ArchetypeType;
};
export declare type ATLambda = {
    node: "lambda";
    arg_type: ArchetypeType;
    ret_type: ArchetypeType;
};
export declare type ATTuple = {
    "node": "tuple";
    "args": Array<ArchetypeType>;
};
export declare type ArchetypeType = ATSimple | ATSapling | ATNamed | ATSingle | ATMap | ATOr | ATLambda | ATTuple;
export declare type RawArchetypeType = {
    node: "address" | "aggregate" | "asset_container" | "asset_key" | "asset_value" | "asset_view" | "asset" | "big_map" | "bls12_381_fr" | "bls12_381_g1" | "bls12_381_g2" | "bool" | "bytes" | "chain_id" | "chest_key" | "chest" | "collection" | "contract" | "currency" | "date" | "duration" | "enum" | "event" | "int" | "iterable_big_map" | "key_hash" | "key" | "lambda" | "list" | "map" | "nat" | "never" | "operation" | "option" | "or" | "partition" | "rational" | "record" | "sapling_state" | "sapling_transaction" | "set" | "signature" | "state" | "string" | "ticket" | "timestamp" | "tuple" | "unit";
    name: string | null;
    int_value: number | null;
    args: Array<RawArchetypeType>;
};
export declare type MTPrimSimple = {
    prim: "address" | "bls12_381_fr" | "bls12_381_g1" | "bls12_381_g2" | "bool" | "bytes" | "chain_id" | "chest_key" | "chest" | "int" | "key_hash" | "key" | "mutez" | "nat" | "never" | "operation" | "signature" | "string" | "timestamp" | "unit";
    annots?: Array<string>;
};
export declare type MTPrimSingle = {
    prim: "contract" | "list" | "option" | "set" | "ticket";
    annots?: Array<string>;
    args: [MichelsonType];
};
export declare type MTPrimSingleInt = {
    prim: "sapling_state" | "sapling_transaction";
    annots?: Array<string>;
    args: [MTInt];
};
export declare type MTPrimPair = {
    prim: "big_map" | "lambda" | "map" | "or";
    annots?: Array<string>;
    args: [MichelsonType, MichelsonType];
};
export declare type MTPrimMulti = {
    prim: "pair";
    annots?: Array<string>;
    args: Array<MichelsonType>;
};
export declare type MTInt = {
    int: string;
};
export declare type MichelsonType = MTPrimSimple | MTPrimSingle | MTPrimSingleInt | MTPrimPair | MTPrimMulti;
export declare type MDPrimSimple = {
    prim: "False" | "None" | "True" | "Unit";
};
export declare type MDPrimSingle = {
    prim: "Left" | "Right" | "Some";
    args: [MichelsonData];
};
export declare type MDPrimPair = {
    prim: "Elt";
    args: [MichelsonData, MichelsonData];
};
export declare type MDPrimMulti = {
    prim: "Pair";
    args: Array<MichelsonData>;
};
export declare type MDString = {
    string: string;
};
export declare type MDInt = {
    int: string;
};
export declare type MDBytes = {
    bytes: string;
};
export declare type MDArray = Array<MichelsonData>;
export declare type MichelsonData = MDString | MDInt | MDBytes | MDArray | MDPrimSimple | MDPrimSingle | MDPrimPair | MDPrimMulti;
export declare type RawMicheline = {
    "prim": string | null;
    "int": string | null;
    "bytes": string | null;
    "string": string | null;
    "args": Array<RawMicheline>;
    "annots": Array<string>;
    "array": Array<RawMicheline>;
};
declare type ContractParameterGen<AT> = {
    "name": string;
    "type": AT;
    "const": boolean;
    "default": string | null;
};
export declare type ContractParameter = ContractParameterGen<ArchetypeType>;
declare type FunctionParameterGen<AT> = {
    "name": string;
    "type": AT;
};
export declare type FunctionParameter = FunctionParameterGen<ArchetypeType>;
declare type EntrypointGen<AT> = {
    "name": string;
    "args": Array<FunctionParameterGen<AT>>;
};
export declare type Entrypoint = EntrypointGen<ArchetypeType>;
declare type FieldGen<AT> = {
    "name": string;
    "type": AT;
    "is_key": boolean;
};
export declare type Field = FieldGen<ArchetypeType>;
declare type AssetGen<AT, MT> = {
    "name": string;
    "container_kind": "map" | "big_map" | "iterable_big_map";
    "fields": Array<FieldGen<AT>>;
    "container_type_michelson": MT;
    "key_type_michelson": MT;
    "value_type_michelson": MT;
};
export declare type Asset = AssetGen<ArchetypeType, MichelsonType>;
declare type EnumValueGen<T> = {
    "name": string;
    "types": Array<T>;
};
export declare type EnumValue = EnumValueGen<ArchetypeType>;
declare type EnumGen<AT, MT> = {
    "name": string;
    "constructors": Array<EnumValueGen<AT>>;
    "type_michelson": MT;
};
export declare type Enum = EnumGen<ArchetypeType, MichelsonType>;
declare type StorageElementGen<AT> = {
    "name": string;
    "type": AT;
    "const": boolean;
};
export declare type StorageElement = StorageElementGen<ArchetypeType>;
declare type RecordGen<AT, MT> = {
    "name": string;
    "fields": Array<Omit<FieldGen<AT>, "is_key">>;
    "type_michelson": MT;
};
export declare type Record = RecordGen<ArchetypeType, MichelsonType>;
declare type GetterGen<AT, MT> = {
    "name": string;
    "args": Array<FunctionParameterGen<AT>>;
    "return": AT;
    "return_michelson": {
        "value": MT;
        "is_storable": boolean;
    };
};
export declare type Getter = GetterGen<ArchetypeType, MichelsonType>;
declare type ViewGen<AT> = {
    "name": string;
    "args": Array<FunctionParameterGen<AT>>;
    "return": AT;
};
export declare type View = ViewGen<ArchetypeType>;
declare type EventGen<AT, MT> = {
    "name": string;
    "fields": Array<Omit<FieldGen<AT>, "is_key">>;
    "type_michelson": MT;
};
export declare type Event = EventGen<ArchetypeType, MichelsonType>;
declare type ErrorGen<MD> = {
    "kind": string;
    "args": Array<string>;
    "expr": MD;
};
export declare type Error = ErrorGen<MichelsonData>;
export declare type ContractInterfaceGen<AT, MT, MD> = {
    "name": string;
    "parameters": Array<ContractParameterGen<AT>>;
    "types": {
        "assets": Array<AssetGen<AT, MT>>;
        "enums": Array<EnumGen<AT, MT>>;
        "records": Array<RecordGen<AT, MT>>;
        "events": Array<EventGen<AT, MT>>;
    };
    "storage": Array<StorageElementGen<AT>>;
    "storage_type": {
        "value": MT;
        "is_storable": boolean;
    };
    "entrypoints": Array<EntrypointGen<AT>>;
    "getters": Array<GetterGen<AT, MT>>;
    "views": Array<ViewGen<AT>>;
    "errors": Array<ErrorGen<MD>>;
};
export declare type RawContractInterface = ContractInterfaceGen<RawArchetypeType, RawMicheline, RawMicheline>;
export declare type ContractInterface = ContractInterfaceGen<ArchetypeType, MichelsonType, MichelsonData>;
declare type TaquitoEnv = {
    in_map_key: boolean;
};
export declare const makeTaquitoEnv: () => TaquitoEnv;
export declare type UnsafeMicheline = {
    prim: string;
    annots?: Array<string>;
    args?: Array<UnsafeMicheline>;
} | {
    string: string;
} | {
    int: string;
} | {
    bytes: string;
} | {
    var: string;
} | Array<UnsafeMicheline>;
export declare const to_literal: (mich: UnsafeMicheline) => ts.PrimaryExpression;
export declare type PathItemSimple = [number];
export declare type PathItemDouble = [number, number];
export declare type PathItem = PathItemSimple | PathItemDouble;
export declare const get_size_michelson_type: (ty: MichelsonType) => number;
export declare const get_path: (id: string, sty: MichelsonType) => Array<PathItem>;
export declare const make_arg: (expr: ts.Expression, pi: PathItem, q?: boolean) => ts.CallExpression | ts.ElementAccessExpression;
export declare enum e_left_right {
    Left = "Left",
    Right = "Right"
}
export declare const compute_path_enum: (idx: number, length: number) => Array<e_left_right>;
export declare const archetype_type_to_mich_type: (at: ArchetypeType, ci: ContractInterface) => MichelsonType;
export declare const archetype_type_to_ts_type: (at: ArchetypeType, ci: ContractInterface) => KeywordTypeNode<any>;
export declare const make_cmp_body: (a: ts.Expression, b: ts.Expression, atype: ArchetypeType, ci: ContractInterface) => ts.Expression;
export declare const mich_to_archetype_type: (atype: ArchetypeType, arg: ts.Expression, ci: ContractInterface) => ts.Expression;
export declare const get_record_or_event_type: (name: string | null, ci: ContractInterface) => RecordGen<ArchetypeType, MichelsonType>;
export declare const is_asset_one_field_key: (name: string, ci: ContractInterface) => [boolean, ArchetypeType | null];
export declare const is_asset_one_field_val: (name: string, ci: ContractInterface) => [boolean, ArchetypeType | null];
export declare const unit_to_mich: () => ts.CallExpression;
export declare const function_param_to_mich: (fp: FunctionParameter, ci: ContractInterface) => ts.CallExpression;
export declare const function_params_to_mich: (a: Array<FunctionParameter>, ci: ContractInterface) => ts.CallExpression | ts.PropertyAccessExpression;
export declare const storage_to_mich: (mt: MichelsonType, selts: Array<StorageElement>, ci: ContractInterface) => ts.Expression;
/**
 * Generates To Michelson TS expression that follows its Michelson Type structure
 * @param v value name
 * @param mt local michelson type
 * @param fields base of fields for type lookup
 * @param fidx field index
 * @returns pair of number of fields looked up so far and 'to_mich' expression
 */
export declare const entity_to_mich: (v: string, mt: MichelsonType, fields: Array<Partial<Field>>, fidx: number | undefined, ci: ContractInterface) => [number, ts.CallExpression];
export declare const value_to_mich_type: (mt: MichelsonType) => ts.CallExpression;
export declare const to_label: (input: string) => string;
export declare const mich_type_to_error: (expr: MichelsonData) => [string, ts.Expression] | null;
export declare const make_error: (error: Error) => [string, ts.Expression] | null;
export declare const make_to_string_decl: () => ts.MethodDeclaration;
export declare const get_constructor: () => ts.ConstructorDeclaration;
export declare const get_get_address_decl: () => ts.MethodDeclaration;
export declare const get_get_balance_decl: () => ts.MethodDeclaration;
export declare const raw_to_contract_interface: (rci: RawContractInterface) => ContractInterface;
export declare const to_michelson_type: (rmt: RawMicheline) => MichelsonType;
export {};
//# sourceMappingURL=utils.d.ts.map
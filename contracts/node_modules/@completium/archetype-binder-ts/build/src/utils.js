"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.to_michelson_type = exports.raw_to_contract_interface = exports.get_get_balance_decl = exports.get_get_address_decl = exports.get_constructor = exports.make_to_string_decl = exports.make_error = exports.mich_type_to_error = exports.to_label = exports.value_to_mich_type = exports.entity_to_mich = exports.storage_to_mich = exports.function_params_to_mich = exports.function_param_to_mich = exports.unit_to_mich = exports.is_asset_one_field_val = exports.is_asset_one_field_key = exports.get_record_or_event_type = exports.mich_to_archetype_type = exports.make_cmp_body = exports.archetype_type_to_ts_type = exports.archetype_type_to_mich_type = exports.compute_path_enum = exports.e_left_right = exports.make_arg = exports.get_path = exports.get_size_michelson_type = exports.to_literal = exports.makeTaquitoEnv = void 0;
const typescript_1 = __importStar(require("typescript"));
const makeTaquitoEnv = () => {
    return { in_map_key: false };
};
exports.makeTaquitoEnv = makeTaquitoEnv;
const to_literal = (mich) => {
    var _a, _b;
    const f = (tag, value) => {
        return typescript_1.factory.createPropertyAssignment(typescript_1.factory.createStringLiteral(tag), value);
    };
    const to_literal_basic = (tag, value) => {
        return typescript_1.factory.createObjectLiteralExpression([f(tag, typescript_1.factory.createStringLiteral(value))], false);
    };
    const to_prim = (prim, args, annots) => {
        const lannots = annots ? annots.map(x => typescript_1.factory.createStringLiteral(x)) : [];
        const largs = args ? args.map(x => (0, exports.to_literal)(x)) : [];
        let elts = [f("prim", typescript_1.factory.createStringLiteral(prim))];
        if (lannots.length > 0) {
            const item = typescript_1.factory.createArrayLiteralExpression(lannots, false);
            elts.push(f("annots", item));
        }
        if (largs.length > 0) {
            const item = typescript_1.factory.createArrayLiteralExpression(largs, false);
            elts.push(f("args", item));
        }
        return typescript_1.factory.createObjectLiteralExpression(elts, false);
    };
    if (mich.string != null) {
        return to_literal_basic("string", mich.string);
    }
    else if (mich.bytes != null) {
        return to_literal_basic("bytes", mich.bytes);
    }
    else if (mich.int != null) {
        return to_literal_basic("int", mich.int);
    }
    else if (mich.var) {
        return to_literal_basic("var", mich.var);
    }
    else if (mich.prim) {
        const m = mich;
        return to_prim(m.prim, (_a = m.args) !== null && _a !== void 0 ? _a : [], (_b = m.annots) !== null && _b !== void 0 ? _b : []);
    }
    else if (mich && mich.length >= 0) {
        return typescript_1.factory.createArrayLiteralExpression(mich.map(x => (0, exports.to_literal)(x)), false);
    }
    else {
        throw (`Cannot convert micheline in primary expression: ${JSON.stringify(mich)}`);
    }
};
exports.to_literal = to_literal;
const get_size_michelson_type = (ty) => {
    switch (ty.prim) {
        case "address": return 1;
        case "big_map": return 1;
        case "bls12_381_fr": return 1;
        case "bls12_381_g1": return 1;
        case "bls12_381_g2": return 1;
        case "bool": return 1;
        case "bytes": return 1;
        case "chain_id": return 1;
        case "chest_key": return 1;
        case "chest": return 1;
        case "contract": return 1;
        case "int": return 1;
        case "key_hash": return 1;
        case "key": return 1;
        case "lambda": return 1;
        case "list": return 1;
        case "map": return 1;
        case "mutez": return 1;
        case "nat": return 1;
        case "never": return 1;
        case "operation": return 1;
        case "option": return 1;
        case "or": return 1;
        case "pair": return (ty.args.length - 1 + (0, exports.get_size_michelson_type)(ty.args[ty.args.length - 1]));
        case "sapling_state": return 1;
        case "sapling_transaction": return 1;
        case "set": return 1;
        case "signature": return 1;
        case "string": return 1;
        case "ticket": return 1;
        case "timestamp": return 1;
        case "unit": return 1;
    }
};
exports.get_size_michelson_type = get_size_michelson_type;
const get_path = (id, sty) => {
    const aux = (ty, accu) => {
        var _a;
        if (ty.annots && ((_a = ty.annots) === null || _a === void 0 ? void 0 : _a.length) > 0 && ty.annots[0] == id) {
            return accu;
        }
        if (ty.prim == "pair") {
            for (let i = 0; i < ty.args.length; ++i) {
                const is_last = i == ty.args.length - 1;
                let ii = [i];
                if (is_last) {
                    const size = (0, exports.get_size_michelson_type)(ty.args[i]);
                    if (size > 1) {
                        ii = [i, (i + size)];
                    }
                }
                const npath = accu.concat([]);
                npath.push(ii);
                const r = aux(ty.args[i], npath);
                if (r) {
                    return r;
                }
            }
        }
        return undefined;
    };
    const res = aux(sty, []);
    return res !== null && res !== void 0 ? res : [];
};
exports.get_path = get_path;
const make_arg = (expr, pi, q) => {
    if (pi.length == 1) {
        const [n] = pi;
        return typescript_1.factory.createElementAccessExpression(q != undefined && q ?
            typescript_1.factory.createPropertyAccessChain(expr, typescript_1.factory.createToken(typescript_1.default.SyntaxKind.QuestionDotToken), typescript_1.factory.createIdentifier("args")) :
            typescript_1.factory.createPropertyAccessExpression(expr, typescript_1.factory.createIdentifier("args")), typescript_1.factory.createNumericLiteral(n));
    }
    else if (pi.length == 2) {
        const [start, end] = pi;
        return typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("pair_to_mich")), undefined, [typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createPropertyAccessExpression(
            // factory.createParenthesizedExpression(acc),
            typescript_1.factory.createParenthesizedExpression(typescript_1.factory.createAsExpression(expr, typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createQualifiedName(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("Mpair")), undefined))), typescript_1.factory.createIdentifier("args")), typescript_1.factory.createIdentifier("slice")), undefined, [
                typescript_1.factory.createNumericLiteral(start.toString()),
                typescript_1.factory.createNumericLiteral(end.toString())
            ])]);
    }
    else {
        throw new Error("Internal Error");
    }
};
exports.make_arg = make_arg;
var e_left_right;
(function (e_left_right) {
    e_left_right["Left"] = "Left";
    e_left_right["Right"] = "Right";
})(e_left_right = exports.e_left_right || (exports.e_left_right = {}));
const compute_path_enum = (idx, length) => {
    let res = [];
    if (idx == 0 && length == 1) {
        return res;
    }
    for (let i = 0; i < idx; ++i) {
        if (!(i == idx - 1 && idx + 1 == length)) {
            res.push(e_left_right.Right);
        }
    }
    res.push(idx + 1 == length ? e_left_right.Right : e_left_right.Left);
    return res;
};
exports.compute_path_enum = compute_path_enum;
/* Archetype type to Michelson type ---------------------------------------- */
const archetype_type_to_mich_type = (at, ci) => {
    switch (at.node) {
        case "address": return { prim: at.node };
        case "aggregate": {
            const a = get_asset_type(at.name, ci);
            return { prim: "set", args: [a.container_type_michelson] };
        }
        case "asset_container": {
            const a = get_asset_type(at.name, ci);
            return a.container_type_michelson;
        }
        case "asset_key": {
            const a = get_asset_type(at.name, ci);
            return a.key_type_michelson;
        }
        case "asset_value": {
            const a = get_asset_type(at.name, ci);
            return a.value_type_michelson;
        }
        case "asset_view": {
            const a = get_asset_type(at.name, ci);
            return { prim: "set", args: [a.container_type_michelson] };
        }
        case "asset": {
            const a = get_asset_type(at.name, ci);
            return a.container_type_michelson;
        }
        case "big_map": return { prim: at.node, args: [(0, exports.archetype_type_to_mich_type)(at.key_type, ci), (0, exports.archetype_type_to_mich_type)(at.value_type, ci)] };
        case "bls12_381_fr": return { prim: at.node };
        case "bls12_381_g1": return { prim: at.node };
        case "bls12_381_g2": return { prim: at.node };
        case "bool": return { prim: at.node };
        case "bytes": return { prim: at.node };
        case "chain_id": return { prim: at.node };
        case "chest_key": return { prim: at.node };
        case "chest": return { prim: at.node };
        case "collection": throw new Error(`archetype_type_to_mich_type: TODO ${at.node}`);
        case "contract": return { prim: at.node, args: [(0, exports.archetype_type_to_mich_type)(at.arg, ci)] };
        case "currency": return { prim: "mutez" };
        case "date": return { prim: "timestamp" };
        case "duration": return { prim: "nat" };
        case "enum": {
            const a = get_enum_type(at.name, ci);
            return a.type_michelson;
        }
        case "event": {
            const r = (0, exports.get_record_or_event_type)(at.name, ci);
            return r.type_michelson;
        }
        case "int": return { prim: at.node };
        case "iterable_big_map": throw new Error(`archetype_type_to_mich_type: TODO ${at.node}`);
        case "key_hash": return { prim: at.node };
        case "key": return { prim: at.node };
        case "lambda": return { prim: at.node, args: [(0, exports.archetype_type_to_mich_type)(at.arg_type, ci), (0, exports.archetype_type_to_mich_type)(at.ret_type, ci)] };
        case "list": return { prim: at.node, args: [(0, exports.archetype_type_to_mich_type)(at.arg, ci)] };
        case "map": return { prim: at.node, args: [(0, exports.archetype_type_to_mich_type)(at.key_type, ci), (0, exports.archetype_type_to_mich_type)(at.value_type, ci)] };
        case "nat": return { prim: at.node };
        case "never": return { prim: at.node };
        case "operation": return { prim: at.node };
        case "option": return { prim: at.node, args: [(0, exports.archetype_type_to_mich_type)(at.arg, ci)] };
        case "or": return { prim: at.node, args: [(0, exports.archetype_type_to_mich_type)(at.left_type, ci), (0, exports.archetype_type_to_mich_type)(at.right_type, ci)] };
        case "partition": {
            const a = get_asset_type(at.name, ci);
            return { prim: "set", args: [a.container_type_michelson] };
        }
        case "rational": return { prim: "pair", args: [{ prim: "int" }, { prim: "nat" }] };
        case "record": {
            const r = (0, exports.get_record_or_event_type)(at.name, ci);
            return r.type_michelson;
        }
        case "sapling_state": return { prim: at.node, args: [{ int: at.memo_size.toString() }] };
        case "sapling_transaction": return { prim: at.node, args: [{ int: at.memo_size.toString() }] };
        case "set": return { prim: at.node, args: [(0, exports.archetype_type_to_mich_type)(at.arg, ci)] };
        case "signature": return { prim: at.node };
        case "state": return { prim: "int" };
        case "string": return { prim: at.node };
        case "ticket": return { prim: at.node, args: [(0, exports.archetype_type_to_mich_type)(at.arg, ci)] };
        case "timestamp": return { prim: at.node };
        case "tuple": return { prim: "pair", args: at.args.map(x => { return (0, exports.archetype_type_to_mich_type)(x, ci); }) };
        case "unit": return { prim: at.node };
    }
};
exports.archetype_type_to_mich_type = archetype_type_to_mich_type;
/* Archetype type to Typescript type --------------------------------------- */
const archetype_type_to_ts_type = (at, ci) => {
    const throw_error = (ty) => {
        throw new Error(`archetype_type_to_ts_type: '${ty}' type not handled`);
    };
    switch (at.node) {
        case "address": return typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createQualifiedName(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("Address")), undefined);
        case "aggregate": {
            const [is_only_key, ty] = (0, exports.is_asset_one_field_key)(at.name, ci);
            if (is_only_key && ty != null) {
                return (0, exports.archetype_type_to_ts_type)({ node: "set", arg: ty }, ci);
            }
            else {
                return (0, exports.archetype_type_to_ts_type)({ node: "set", arg: { node: "asset_key", name: at.name } }, ci);
            }
        }
        case "asset_container": return throw_error(at.node);
        case "asset_key": {
            const [is_only_key, ty] = (0, exports.is_asset_one_field_key)(at.name, ci);
            if (is_only_key && ty != null) {
                return (0, exports.archetype_type_to_ts_type)(ty, ci);
            }
            else {
                return typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createIdentifier(at.name + "_key"), undefined);
            }
        }
        case "asset_value": {
            const [is_only_val, ty] = (0, exports.is_asset_one_field_val)(at.name, ci);
            if (is_only_val && ty != null) {
                return (0, exports.archetype_type_to_ts_type)(ty, ci);
            }
            else {
                return typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createIdentifier(at.name + "_value"), undefined);
            }
        }
        case "asset_view": {
            const [is_only_key, ty] = (0, exports.is_asset_one_field_key)(at.name, ci);
            if (is_only_key && ty != null) {
                return (0, exports.archetype_type_to_ts_type)({ node: "list", arg: ty }, ci);
            }
            else {
                return (0, exports.archetype_type_to_ts_type)({ node: "list", arg: { node: "asset_key", name: at.name } }, ci);
            }
        }
        case "asset": {
            if (at.name != null) {
                return typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createIdentifier(at.name + "_container"), undefined);
            }
            else {
                throw new Error(`Cannot get asset name (asset)`);
            }
        }
        case "big_map": return typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createIdentifier("Array"), [typescript_1.factory.createTupleTypeNode([
                (0, exports.archetype_type_to_ts_type)(at.key_type, ci),
                (0, exports.archetype_type_to_ts_type)(at.value_type, ci)
            ])]);
        case "bls12_381_fr": return typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createQualifiedName(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("Bls12_381_fr")), undefined);
        case "bls12_381_g1": return typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createQualifiedName(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("Bls12_381_g1")), undefined);
        case "bls12_381_g2": return typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createQualifiedName(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("Bls12_381_g2")), undefined);
        case "bool": return typescript_1.factory.createKeywordTypeNode(typescript_1.SyntaxKind.BooleanKeyword);
        case "bytes": return typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createQualifiedName(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("Bytes")), undefined);
        case "chain_id": return typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createQualifiedName(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("Chain_id")), undefined);
        case "chest_key": return typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createQualifiedName(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("Chest_key")), undefined);
        case "chest": return typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createQualifiedName(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("Chest")), undefined);
        case "collection": return throw_error(at.node);
        case "contract": return typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createQualifiedName(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("Entrypoint")), undefined);
        case "currency": return typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createQualifiedName(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("Tez")), undefined);
        case "date": return typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createIdentifier("Date"), undefined);
        case "duration": return typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createQualifiedName(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("Duration")), undefined);
        case "enum": return typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createIdentifier(at.name != null ? at.name : ""), undefined);
        case "event": {
            return typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createIdentifier(at.name), undefined);
        }
        case "int": return typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createQualifiedName(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("Int")), undefined);
        case "iterable_big_map": return typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createIdentifier("Array"), [typescript_1.factory.createTupleTypeNode([
                (0, exports.archetype_type_to_ts_type)(at.key_type, ci),
                (0, exports.archetype_type_to_ts_type)(at.value_type, ci)
            ])]);
        case "key_hash": return typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createQualifiedName(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("Key_hash")), undefined);
        case "key": return typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createQualifiedName(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("Key")), undefined);
        case "lambda": return typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createQualifiedName(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("Micheline")), undefined);
        case "list": return typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createIdentifier("Array"), [(0, exports.archetype_type_to_ts_type)(at.arg, ci)]);
        case "map": return typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createIdentifier("Array"), [typescript_1.factory.createTupleTypeNode([
                (0, exports.archetype_type_to_ts_type)(at.key_type, ci),
                (0, exports.archetype_type_to_ts_type)(at.value_type, ci)
            ])]);
        case "nat": return typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createQualifiedName(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("Nat")), undefined);
        case "never": return typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createQualifiedName(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("Micheline")), undefined);
        case "operation": return throw_error(at.node);
        case "option": return typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createQualifiedName(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("Option")), [(0, exports.archetype_type_to_ts_type)(at.arg, ci)]);
        case "or": return typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createQualifiedName(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("Or")), [
            (0, exports.archetype_type_to_ts_type)(at.left_type, ci),
            (0, exports.archetype_type_to_ts_type)(at.right_type, ci)
        ]);
        case "partition": {
            const [is_only_key, ty] = (0, exports.is_asset_one_field_key)(at.name, ci);
            if (is_only_key && ty != null) {
                return (0, exports.archetype_type_to_ts_type)({ node: "set", arg: ty }, ci);
            }
            else {
                return (0, exports.archetype_type_to_ts_type)({ node: "set", arg: { node: "asset_key", name: at.name } }, ci);
            }
        }
        case "rational": return typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createQualifiedName(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("Rational")), undefined);
        case "record": {
            return typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createIdentifier(at.name), undefined);
        }
        case "sapling_state": return typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createQualifiedName(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("Sapling_state")), undefined);
        case "sapling_transaction": return typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createQualifiedName(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("Sapling_transaction")), undefined);
        case "set": return typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createIdentifier("Array"), [(0, exports.archetype_type_to_ts_type)(at.arg, ci)]);
        case "signature": return typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createQualifiedName(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("Signature")), undefined);
        case "state": return throw_error(at.node);
        case "string": return typescript_1.factory.createKeywordTypeNode(typescript_1.SyntaxKind.StringKeyword);
        case "ticket": return typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createQualifiedName(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("Ticket")), [(0, exports.archetype_type_to_ts_type)(at.arg, ci)]);
        case "timestamp": return throw_error(at.node);
        case "tuple": return typescript_1.factory.createTupleTypeNode(at.args.map(t => (0, exports.archetype_type_to_ts_type)(t, ci)));
        case "unit": return typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createQualifiedName(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("Unit")), undefined);
    }
};
exports.archetype_type_to_ts_type = archetype_type_to_ts_type;
/* Complex data type comparison generators --------------------------------- */
const rm_milliseconds_from = (x) => {
    return typescript_1.factory.createBinaryExpression(typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(x, typescript_1.factory.createIdentifier("getTime")), undefined, []), typescript_1.factory.createToken(typescript_1.default.SyntaxKind.MinusToken), typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(x, typescript_1.factory.createIdentifier("getMilliseconds")), undefined, []));
};
const make_tuple_cmp_body = (a, b, types, ci) => {
    return typescript_1.factory.createCallExpression(typescript_1.factory.createParenthesizedExpression(typescript_1.factory.createArrowFunction(undefined, undefined, [
        typescript_1.factory.createParameterDeclaration(undefined, undefined, undefined, typescript_1.factory.createIdentifier("x"), undefined, undefined, undefined),
        typescript_1.factory.createParameterDeclaration(undefined, undefined, undefined, typescript_1.factory.createIdentifier("y"), undefined, undefined, undefined)
    ], undefined, typescript_1.factory.createToken(typescript_1.default.SyntaxKind.EqualsGreaterThanToken), typescript_1.factory.createBlock([typescript_1.factory.createReturnStatement(types.slice(1).reduce((acc, t, i) => {
            return typescript_1.factory.createBinaryExpression(acc, typescript_1.factory.createToken(typescript_1.default.SyntaxKind.AmpersandAmpersandToken), (0, exports.make_cmp_body)(typescript_1.factory.createElementAccessExpression(typescript_1.factory.createIdentifier("x"), typescript_1.factory.createNumericLiteral(i + 1)), typescript_1.factory.createElementAccessExpression(typescript_1.factory.createIdentifier("y"), typescript_1.factory.createNumericLiteral(i + 1)), t, ci));
        }, (0, exports.make_cmp_body)(typescript_1.factory.createElementAccessExpression(typescript_1.factory.createIdentifier("x"), typescript_1.factory.createNumericLiteral("0")), typescript_1.factory.createElementAccessExpression(typescript_1.factory.createIdentifier("y"), typescript_1.factory.createNumericLiteral("0")), types[0], ci)))], true))), undefined, [a, b]);
};
const make_cmp_body = (a, b, atype, ci) => {
    const make_cmp_equals = (a, b) => {
        return typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(a, typescript_1.factory.createIdentifier("equals")), undefined, [b]);
    };
    const make_cmp_equals_default = (a, b) => {
        return typescript_1.factory.createBinaryExpression(a, typescript_1.factory.createToken(typescript_1.default.SyntaxKind.EqualsEqualsToken), b);
    };
    const make_cmp_equals_container = (a, b) => {
        return typescript_1.factory.createBinaryExpression(typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier("JSON"), typescript_1.factory.createIdentifier("stringify")), undefined, [a]), typescript_1.factory.createToken(typescript_1.default.SyntaxKind.EqualsEqualsToken), typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier("JSON"), typescript_1.factory.createIdentifier("stringify")), undefined, [b]));
    };
    switch (atype.node) {
        case "address": return make_cmp_equals(a, b);
        case "aggregate": return make_cmp_equals_default(a, b);
        case "asset_container": return make_cmp_equals_default(a, b);
        case "asset_key": {
            const [is_only_key, ty] = (0, exports.is_asset_one_field_key)(atype.name, ci);
            if (is_only_key && ty != null) {
                return (0, exports.make_cmp_body)(a, b, ty, ci);
            }
            else {
                return make_cmp_equals_default(a, b);
            }
        }
        case "asset_value": {
            const [is_only_val, ty] = (0, exports.is_asset_one_field_val)(atype.name, ci);
            if (is_only_val && ty != null) {
                return (0, exports.make_cmp_body)(a, b, ty, ci);
            }
            else {
                return make_cmp_equals_default(a, b);
            }
        }
        case "asset_view": return make_cmp_equals_default(a, b);
        case "asset": return make_cmp_equals_container(a, b);
        case "big_map": return make_cmp_equals_default(a, b);
        case "bls12_381_fr": return make_cmp_equals(a, b);
        case "bls12_381_g1": return make_cmp_equals(a, b);
        case "bls12_381_g2": return make_cmp_equals(a, b);
        case "bool": return make_cmp_equals_default(a, b);
        case "bytes": return make_cmp_equals(a, b);
        case "chain_id": return make_cmp_equals(a, b);
        case "chest_key": return make_cmp_equals(a, b);
        case "chest": return make_cmp_equals(a, b);
        case "collection": return make_cmp_equals_default(a, b);
        case "contract": return make_cmp_equals(a, b);
        case "currency": return make_cmp_equals(a, b);
        case "date": return typescript_1.factory.createBinaryExpression(typescript_1.factory.createParenthesizedExpression(rm_milliseconds_from(a)), typescript_1.factory.createToken(typescript_1.default.SyntaxKind.EqualsEqualsToken), typescript_1.factory.createParenthesizedExpression(rm_milliseconds_from(b)));
        case "duration": return make_cmp_equals(a, b);
        case "enum": return make_cmp_equals_default(a, b);
        case "event": return make_cmp_equals_default(a, b);
        case "int": return make_cmp_equals(a, b);
        case "iterable_big_map": return make_cmp_equals_default(a, b);
        case "key_hash": return make_cmp_equals(a, b);
        case "key": return make_cmp_equals(a, b);
        case "lambda": return make_cmp_equals_default(a, b);
        case "list": return make_cmp_equals_container(a, b);
        case "map": return make_cmp_equals_container(a, b);
        case "nat": return make_cmp_equals(a, b);
        case "never": return make_cmp_equals_default(a, b);
        case "operation": return make_cmp_equals_default(a, b);
        case "option": return make_cmp_equals(a, b);
        case "or": return make_cmp_equals(a, b);
        case "partition": return make_cmp_equals_default(a, b);
        case "rational": return make_cmp_equals(a, b);
        case "record": return make_cmp_equals_default(a, b);
        case "sapling_state": return make_cmp_equals(a, b);
        case "sapling_transaction": return make_cmp_equals(a, b);
        case "set": return make_cmp_equals_container(a, b);
        case "signature": return make_cmp_equals(a, b);
        case "state": return make_cmp_equals(a, b);
        case "string": return make_cmp_equals_default(a, b);
        case "ticket": return make_cmp_equals(a, b);
        case "timestamp": return make_cmp_equals_default(a, b);
        case "tuple": return make_tuple_cmp_body(a, b, atype.args, ci);
        case "unit": return make_cmp_equals(a, b);
    }
};
exports.make_cmp_body = make_cmp_body;
/* Michelson to Typescript utils ----------------------------------------------------- */
const mich_to_archetype_type = (atype, arg, ci) => {
    const TODO = (ty, x) => {
        throw new Error(`TODO: ${ty}`);
    };
    const get_size = (aty) => {
        switch (aty.node) {
            case "address": return 1;
            case "aggregate": return 1;
            case "asset_container": return 1;
            case "asset_key": return 1;
            case "asset_value": return 1;
            case "asset_view": return 1;
            case "asset": return 1;
            case "big_map": return 1;
            case "bls12_381_fr": return 1;
            case "bls12_381_g1": return 1;
            case "bls12_381_g2": return 1;
            case "bool": return 1;
            case "bytes": return 1;
            case "chain_id": return 1;
            case "chest_key": return 1;
            case "chest": return 1;
            case "collection": return 1;
            case "contract": return 1;
            case "currency": return 1;
            case "date": return 1;
            case "duration": return 1;
            case "enum": return 1;
            case "event": return 1;
            case "int": return 1;
            case "iterable_big_map": return 3;
            case "key_hash": return 1;
            case "key": return 1;
            case "lambda": return 1;
            case "list": return 1;
            case "map": return 1;
            case "nat": return 1;
            case "never": return 1;
            case "operation": return 1;
            case "option": return 1;
            case "or": return 1;
            case "partition": return 1;
            case "rational": return 2;
            case "record": {
                const r = (0, exports.get_record_or_event_type)(aty.name, ci);
                return (0, exports.get_size_michelson_type)(r.type_michelson);
            }
            case "sapling_state": return 1;
            case "sapling_transaction": return 1;
            case "set": return 1;
            case "signature": return 1;
            case "state": return 1;
            case "string": return 1;
            case "ticket": return 1;
            case "timestamp": return 1;
            case "tuple": return (aty.args.length - 1 + get_size(aty.args[aty.args.length - 1]));
            case "unit": return 1;
        }
    };
    const class_to_mich = (id, args) => {
        return typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier(id)), undefined, args);
    };
    const class_from_mich = (name, args) => {
        return typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier(name)), typescript_1.factory.createIdentifier("from_mich")), undefined, args);
    };
    const map_mich_to_ts = (key_type, value_type) => {
        return typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("mich_to_map")), undefined, [
            arg,
            typescript_1.factory.createArrowFunction(undefined, undefined, [
                typescript_1.factory.createParameterDeclaration(undefined, undefined, undefined, typescript_1.factory.createIdentifier("x"), undefined, undefined, undefined),
                typescript_1.factory.createParameterDeclaration(undefined, undefined, undefined, typescript_1.factory.createIdentifier("y"), undefined, undefined, undefined)
            ], undefined, typescript_1.factory.createToken(typescript_1.default.SyntaxKind.EqualsGreaterThanToken), typescript_1.factory.createArrayLiteralExpression([
                (0, exports.mich_to_archetype_type)(key_type, typescript_1.factory.createIdentifier("x"), ci),
                (0, exports.mich_to_archetype_type)(value_type, typescript_1.factory.createIdentifier("y"), ci)
            ], false))
        ]);
    };
    const contained_type_to_field_decl = (fname, arg, atypes, from_mich) => {
        return typescript_1.factory.createCallExpression(from_mich ? typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier(fname)), typescript_1.factory.createIdentifier("from_mich")) : typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier(fname)), undefined, [arg].concat(atypes.map(atype => {
            return typescript_1.factory.createArrowFunction(undefined, undefined, [typescript_1.factory.createParameterDeclaration(undefined, undefined, undefined, typescript_1.factory.createIdentifier("x"), undefined, undefined, undefined)], undefined, typescript_1.factory.createToken(typescript_1.default.SyntaxKind.EqualsGreaterThanToken), typescript_1.factory.createBlock([typescript_1.factory.createReturnStatement((0, exports.mich_to_archetype_type)(atype, typescript_1.factory.createIdentifier("x"), ci))], false));
        })));
    };
    const mich_to_tuple = (types, arg) => {
        const decls = [];
        const args = [];
        for (let i = 0; i < types.length; i++) {
            const aty = types[i];
            let pi = [i];
            if (i == types.length - 1) {
                const size = get_size(aty);
                if (size > 1) {
                    pi = [i, i + size];
                }
            }
            const expr_arg = typescript_1.factory.createAsExpression(typescript_1.factory.createIdentifier("p"), typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createQualifiedName(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("Mpair")), undefined));
            const narg = (0, exports.make_arg)(expr_arg, pi);
            args.push((0, exports.mich_to_archetype_type)(types[i], narg, ci));
        }
        const body = [...decls, typescript_1.factory.createReturnStatement(typescript_1.factory.createArrayLiteralExpression(args))];
        return typescript_1.factory.createCallExpression(typescript_1.factory.createParenthesizedExpression(typescript_1.factory.createArrowFunction(undefined, undefined, [typescript_1.factory.createParameterDeclaration(undefined, undefined, undefined, typescript_1.factory.createIdentifier("p"), undefined, undefined, undefined)], undefined, typescript_1.factory.createToken(typescript_1.default.SyntaxKind.EqualsGreaterThanToken), typescript_1.factory.createBlock(body, true))), undefined, [arg]);
    };
    const record_to_mich = (record_name, arg, ci) => {
        return typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier(record_name), typescript_1.factory.createIdentifier("from_mich")), undefined, [arg]);
    };
    const enum_to_mich = (enum_name, arg, ci) => {
        return typescript_1.factory.createCallExpression(typescript_1.factory.createIdentifier("mich_to_" + enum_name), undefined, [arg]);
    };
    const asset_to_mich = (asset_name, arg, ci) => {
        const asset_type = get_asset_type(asset_name, ci);
        const is_only_keys = (a) => {
            return a.fields.reduce((accu, x) => { return accu && x.is_key; }, true);
        };
        switch (asset_type.container_kind) {
            case "map": {
                let key_type = { node: "asset_key", name: asset_name };
                const [is_one_field_key, key_ty] = (0, exports.is_asset_one_field_key)(asset_name, ci);
                if (is_one_field_key && key_ty != null) {
                    key_type = key_ty;
                }
                if (is_only_keys(asset_type)) {
                    return contained_type_to_field_decl("mich_to_list", arg, [key_type], false);
                }
                else {
                    let value_type = { node: "asset_value", name: asset_name };
                    const [is_one_field_val, val_ty] = (0, exports.is_asset_one_field_val)(asset_name, ci);
                    if (is_one_field_val && val_ty != null) {
                        value_type = val_ty;
                    }
                    return map_mich_to_ts(key_type, value_type);
                }
            }
            case "big_map":
                return class_from_mich("Int", [arg]);
            case "iterable_big_map": {
                const key_type = { node: "asset_key", name: asset_name };
                const val_type = { node: "asset_value", name: asset_name };
                const values = { node: 'big_map', key_type: key_type, value_type: { node: 'tuple', args: [{ node: 'nat' }, val_type] } };
                const keys = { node: 'big_map', key_type: { node: 'nat' }, value_type: key_type };
                const size = { node: 'nat' };
                return mich_to_tuple([values, keys, size], arg);
            }
        }
    };
    function mich_unit() {
        return typescript_1.factory.createNewExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("Unit")), undefined, []);
    }
    switch (atype.node) {
        case "address": return class_from_mich("Address", [arg]);
        case "aggregate": {
            const [a, ty] = (0, exports.is_asset_one_field_key)(atype.name, ci);
            if (a && ty != null) {
                return (0, exports.mich_to_archetype_type)({ node: 'set', arg: ty }, arg, ci);
            }
            else {
                return (0, exports.mich_to_archetype_type)({ node: 'set', arg: { node: "record", name: atype.name + "_key" } }, arg, ci);
            }
        }
        case "asset_container": return TODO("asset_container", arg);
        case "asset_key": {
            const [a, ty] = (0, exports.is_asset_one_field_key)(atype.name, ci);
            if (a && ty != null) {
                return (0, exports.mich_to_archetype_type)(ty, arg, ci);
            }
            else {
                return record_to_mich(atype.name + "_key", arg, ci);
            }
        }
        case "asset_value": {
            const [a, ty] = (0, exports.is_asset_one_field_val)(atype.name, ci);
            if (a && ty != null) {
                return (0, exports.mich_to_archetype_type)(ty, arg, ci);
            }
            else {
                return record_to_mich(atype.name + "_value", arg, ci);
            }
        }
        case "asset_view": {
            const [a, ty] = (0, exports.is_asset_one_field_key)(atype.name, ci);
            if (a && ty != null) {
                return (0, exports.mich_to_archetype_type)({ node: "list", arg: ty }, arg, ci);
            }
            else {
                return (0, exports.mich_to_archetype_type)({ node: "list", arg: { node: "record", name: atype.name + "_key" } }, arg, ci);
            }
        }
        case "asset": return asset_to_mich(atype.name, arg, ci);
        case "big_map": return class_from_mich("Int", [arg]);
        case "bls12_381_fr": return class_from_mich("Bls12_381_fr", [arg]);
        case "bls12_381_g1": return class_from_mich("Bls12_381_g1", [arg]);
        case "bls12_381_g2": return class_from_mich("Bls12_381_g2", [arg]);
        case "bool": return class_to_mich("mich_to_bool", [arg]);
        case "bytes": return class_from_mich("Bytes", [arg]);
        case "chain_id": return class_from_mich("Chain_id", [arg]);
        case "chest_key": return class_from_mich("Chest_key", [arg]);
        case "chest": return class_from_mich("Chest", [arg]);
        case "collection": return TODO("collection", arg);
        case "contract": return class_from_mich("Entrypoint", [arg]);
        case "currency": return class_from_mich("Tez", [arg]);
        case "date": return class_to_mich("mich_to_date", [arg]);
        case "duration": return class_from_mich("Duration", [arg]);
        case "enum": return enum_to_mich(atype.name, arg, ci);
        case "event": return record_to_mich(atype.name, arg, ci);
        case "int": return class_from_mich("Int", [arg]);
        case "iterable_big_map": return class_from_mich("Int", [arg]);
        case "key_hash": return class_from_mich("Key_hash", [arg]);
        case "key": return class_from_mich("Key", [arg]);
        case "lambda": return arg;
        case "list": return contained_type_to_field_decl("mich_to_list", arg, [atype.arg], false);
        case "map": return map_mich_to_ts(atype.key_type, atype.value_type);
        case "nat": return class_from_mich("Nat", [arg]);
        case "never": return arg;
        case "operation": return TODO("operation", arg);
        case "option": return contained_type_to_field_decl("Option", arg, [atype.arg], true);
        case "or": return contained_type_to_field_decl("Or", arg, [atype.left_type, atype.right_type], true);
        case "partition": {
            const [a, ty] = (0, exports.is_asset_one_field_key)(atype.name, ci);
            if (a && ty != null) {
                return (0, exports.mich_to_archetype_type)({ node: 'set', arg: ty }, arg, ci);
            }
            else {
                return (0, exports.mich_to_archetype_type)({ node: 'set', arg: { node: "record", name: atype.name + "_key" } }, arg, ci);
            }
        }
        case "rational": return class_from_mich("Rational", [arg]);
        case "record": return record_to_mich(atype.name, arg, ci);
        case "sapling_state": return class_from_mich("Sapling_state", [arg]);
        case "sapling_transaction": return class_from_mich("Sapling_transaction", [arg]);
        case "set": return contained_type_to_field_decl("mich_to_list", arg, [atype.arg], false);
        case "signature": return class_from_mich("Signature", [arg]);
        case "state": return TODO("state", arg);
        case "string": return class_to_mich("mich_to_string", [arg]);
        case "ticket": return contained_type_to_field_decl("Ticket", arg, [atype.arg], true);
        case "timestamp": return class_from_mich("Int", [arg]);
        case "tuple": return mich_to_tuple(atype.args, arg);
        case "unit": return mich_unit();
    }
};
exports.mich_to_archetype_type = mich_to_archetype_type;
/* storage element getter formulas ----------------------------------------- */
const get_record_or_event_type = (name, ci) => {
    if (name != null) {
        for (let i = 0; i < ci.types.records.length; i++) {
            if (ci.types.records[i].name == name) {
                return ci.types.records[i];
            }
        }
        for (let i = 0; i < ci.types.events.length; i++) {
            if (ci.types.events[i].name == name) {
                return ci.types.events[i];
            }
        }
    }
    throw new Error("get_record_or_event_type: '" + name + "' not found");
};
exports.get_record_or_event_type = get_record_or_event_type;
const get_asset_type = (name, ci) => {
    if (name != null) {
        for (let i = 0; i < ci.types.assets.length; i++) {
            if (ci.types.assets[i].name == name) {
                return ci.types.assets[i];
            }
        }
    }
    throw new Error("get_asset_type: '" + name + "' not found");
};
const is_asset_one_field_key = (name, ci) => {
    const a = get_asset_type(name, ci);
    const [cpt, ty] = a.fields.reduce(([c, ty], x) => {
        if (x.is_key) {
            return [c + 1, x.type];
        }
        else {
            return [c, ty];
        }
    }, [0, null]);
    return [cpt == 1, ty];
};
exports.is_asset_one_field_key = is_asset_one_field_key;
const is_asset_one_field_val = (name, ci) => {
    const a = get_asset_type(name, ci);
    const [cpt, ty] = a.fields.reduce(([c, ty], x) => {
        if (!x.is_key) {
            return [c + 1, x.type];
        }
        else {
            return [c, ty];
        }
    }, [0, null]);
    return [cpt == 1, ty];
};
exports.is_asset_one_field_val = is_asset_one_field_val;
const get_enum_type = (name, ci) => {
    if (name != null) {
        for (let i = 0; i < ci.types.enums.length; i++) {
            if (ci.types.enums[i].name == name) {
                return ci.types.enums[i];
            }
        }
    }
    throw new Error("get_enum_type: '" + name + "' not found");
};
/* Typescript To Micheline utils ------------------------------------------------------ */
const class_to_mich = (x) => {
    return typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(x, typescript_1.factory.createIdentifier("to_mich")), undefined, []);
};
const id_to_mich = (x) => {
    return typescript_1.factory.createCallExpression(typescript_1.factory.createParenthesizedExpression(typescript_1.factory.createArrowFunction(undefined, undefined, [typescript_1.factory.createParameterDeclaration(undefined, undefined, undefined, typescript_1.factory.createIdentifier("x"), undefined, undefined, undefined)], undefined, typescript_1.factory.createToken(typescript_1.default.SyntaxKind.EqualsGreaterThanToken), typescript_1.factory.createIdentifier("x"))), undefined, [x]);
};
const string_to_mich = (x) => {
    return typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("string_to_mich")), undefined, [x]);
};
const unit_to_mich = () => {
    return typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("unit_to_mich")), undefined, []);
};
exports.unit_to_mich = unit_to_mich;
const bool_to_mich = (x) => {
    return typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("bool_to_mich")), undefined, [x]);
};
const date_to_mich = (x) => {
    return typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("date_to_mich")), undefined, [x]);
};
const tuple_to_mich = (name, types, ci) => {
    return typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("pair_to_mich")), undefined, [typescript_1.factory.createArrayLiteralExpression(types.map((x, i) => (0, exports.function_param_to_mich)({ name: name + "[" + i.toString() + "]", type: x }, ci)), false)]);
};
const record_or_event_to_mich = (fp, ci) => {
    const v = (0, exports.get_record_or_event_type)(fp.type.name, ci);
    if (v.fields.length == 1) {
        const aty = v.fields[0].type;
        return (0, exports.function_param_to_mich)(Object.assign(Object.assign({}, fp), { type: aty }), ci);
    }
    else {
        return class_to_mich(typescript_1.factory.createIdentifier(fp.name));
    }
};
const list_to_mich = (name, atype, ci) => {
    return internal_list_to_mich(name, [
        typescript_1.factory.createReturnStatement((0, exports.function_param_to_mich)({ name: "x", type: atype }, ci))
    ]);
};
const internal_list_to_mich = (name, body) => {
    return typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("list_to_mich")), undefined, [
        typescript_1.factory.createIdentifier(name),
        typescript_1.factory.createArrowFunction(undefined, undefined, [typescript_1.factory.createParameterDeclaration(undefined, undefined, undefined, typescript_1.factory.createIdentifier("x"), undefined, undefined, undefined)], undefined, typescript_1.factory.createToken(typescript_1.default.SyntaxKind.EqualsGreaterThanToken), typescript_1.factory.createBlock(body, true))
    ]);
};
const internal_map_to_mich = (name, decls) => {
    return internal_list_to_mich(name, [
        typescript_1.factory.createVariableStatement(undefined, typescript_1.factory.createVariableDeclarationList([typescript_1.factory.createVariableDeclaration(typescript_1.factory.createIdentifier("x_key"), undefined, undefined, typescript_1.factory.createElementAccessExpression(typescript_1.factory.createIdentifier("x"), typescript_1.factory.createNumericLiteral("0")))], typescript_1.default.NodeFlags.Const)),
        typescript_1.factory.createVariableStatement(undefined, typescript_1.factory.createVariableDeclarationList([typescript_1.factory.createVariableDeclaration(typescript_1.factory.createIdentifier("x_value"), undefined, undefined, typescript_1.factory.createElementAccessExpression(typescript_1.factory.createIdentifier("x"), typescript_1.factory.createNumericLiteral("1")))], typescript_1.default.NodeFlags.Const)),
        typescript_1.factory.createReturnStatement(typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("elt_to_mich")), undefined, decls))
    ]);
};
const map_to_mich = (name, key_type, value_type, ci) => {
    if (null == key_type)
        throw new Error("map_to_mich: null key type");
    if (null == value_type)
        throw new Error("map_to_mich: null value type");
    return internal_map_to_mich(name, [
        (0, exports.function_param_to_mich)({ name: "x_key", type: key_type }, ci),
        (0, exports.function_param_to_mich)({ name: "x_value", type: value_type }, ci)
    ]);
};
const function_param_to_mich = (fp, ci) => {
    const throw_error = (ty) => {
        throw new Error("function_param_to_mich: unhandled type '" + ty + "'");
    };
    const option_to_mich = (ty, x) => {
        return typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(x, typescript_1.factory.createIdentifier("to_mich")), undefined, [typescript_1.factory.createParenthesizedExpression(typescript_1.factory.createArrowFunction(undefined, undefined, [typescript_1.factory.createParameterDeclaration(undefined, undefined, undefined, typescript_1.factory.createIdentifier("x"), undefined, undefined, undefined)], undefined, typescript_1.factory.createToken(typescript_1.default.SyntaxKind.EqualsGreaterThanToken), typescript_1.factory.createBlock([typescript_1.factory.createReturnStatement((0, exports.function_param_to_mich)({ name: "x", type: ty }, ci))], false)))]);
    };
    const or_to_mich = (ty_left, ty_right, x) => {
        return typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(x, typescript_1.factory.createIdentifier("to_mich")), undefined, [typescript_1.factory.createParenthesizedExpression(typescript_1.factory.createArrowFunction(undefined, undefined, [typescript_1.factory.createParameterDeclaration(undefined, undefined, undefined, typescript_1.factory.createIdentifier("x"), undefined, undefined, undefined)], undefined, typescript_1.factory.createToken(typescript_1.default.SyntaxKind.EqualsGreaterThanToken), typescript_1.factory.createBlock([typescript_1.factory.createReturnStatement((0, exports.function_param_to_mich)({ name: "x", type: ty_left }, ci))], false))),
            typescript_1.factory.createParenthesizedExpression(typescript_1.factory.createArrowFunction(undefined, undefined, [typescript_1.factory.createParameterDeclaration(undefined, undefined, undefined, typescript_1.factory.createIdentifier("x"), undefined, undefined, undefined)], undefined, typescript_1.factory.createToken(typescript_1.default.SyntaxKind.EqualsGreaterThanToken), typescript_1.factory.createBlock([typescript_1.factory.createReturnStatement((0, exports.function_param_to_mich)({ name: "x", type: ty_right }, ci))], false)))
        ]);
    };
    const ticket_to_mich = (ty, x) => {
        return typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(x, typescript_1.factory.createIdentifier("to_mich")), undefined, [typescript_1.factory.createParenthesizedExpression(typescript_1.factory.createArrowFunction(undefined, undefined, [typescript_1.factory.createParameterDeclaration(undefined, undefined, undefined, typescript_1.factory.createIdentifier("x"), undefined, undefined, undefined)], undefined, typescript_1.factory.createToken(typescript_1.default.SyntaxKind.EqualsGreaterThanToken), typescript_1.factory.createBlock([typescript_1.factory.createReturnStatement((0, exports.function_param_to_mich)({ name: "x", type: ty }, ci))], false)))]);
    };
    switch (fp.type.node) {
        case "address": return class_to_mich(typescript_1.factory.createIdentifier(fp.name));
        case "aggregate": return list_to_mich(fp.name, { node: "asset_key", name: fp.type.name }, ci);
        case "asset_container": return throw_error(fp.type.node);
        case "asset_key": {
            const [is_only_key, ty] = (0, exports.is_asset_one_field_key)(fp.type.name, ci);
            if (is_only_key && ty != null) {
                return (0, exports.function_param_to_mich)({ name: fp.name, type: ty }, ci);
            }
            else {
                return class_to_mich(typescript_1.factory.createIdentifier(fp.name));
            }
        }
        case "asset_value": {
            const [is_only_val, ty] = (0, exports.is_asset_one_field_val)(fp.type.name, ci);
            if (is_only_val && ty != null) {
                return (0, exports.function_param_to_mich)({ name: fp.name, type: ty }, ci);
            }
            else {
                return class_to_mich(typescript_1.factory.createIdentifier(fp.name));
            }
        }
        case "asset_view": return list_to_mich(fp.name, { node: "asset_key", name: fp.type.name }, ci);
        case "asset": return throw_error(fp.type.node);
        case "big_map": return map_to_mich(fp.name, fp.type.key_type, fp.type.value_type, ci);
        case "bls12_381_fr": return class_to_mich(typescript_1.factory.createIdentifier(fp.name));
        case "bls12_381_g1": return class_to_mich(typescript_1.factory.createIdentifier(fp.name));
        case "bls12_381_g2": return class_to_mich(typescript_1.factory.createIdentifier(fp.name));
        case "bool": return bool_to_mich(typescript_1.factory.createIdentifier(fp.name));
        case "bytes": return class_to_mich(typescript_1.factory.createIdentifier(fp.name));
        case "chain_id": return class_to_mich(typescript_1.factory.createIdentifier(fp.name));
        case "chest_key": return class_to_mich(typescript_1.factory.createIdentifier(fp.name));
        case "chest": return class_to_mich(typescript_1.factory.createIdentifier(fp.name));
        case "collection": return throw_error(fp.type.node);
        case "contract": return class_to_mich(typescript_1.factory.createIdentifier(fp.name));
        case "currency": return class_to_mich(typescript_1.factory.createIdentifier(fp.name));
        case "date": return date_to_mich(typescript_1.factory.createIdentifier(fp.name));
        case "duration": return class_to_mich(typescript_1.factory.createIdentifier(fp.name));
        case "enum": return class_to_mich(typescript_1.factory.createIdentifier(fp.name));
        case "event": return record_or_event_to_mich(fp, ci);
        case "int": return class_to_mich(typescript_1.factory.createIdentifier(fp.name));
        case "iterable_big_map": return map_to_mich(fp.name, fp.type.key_type, fp.type.value_type, ci);
        case "key_hash": return class_to_mich(typescript_1.factory.createIdentifier(fp.name));
        case "key": return class_to_mich(typescript_1.factory.createIdentifier(fp.name));
        case "lambda": return id_to_mich(typescript_1.factory.createIdentifier(fp.name));
        case "list": return list_to_mich(fp.name, fp.type.arg, ci);
        case "map": return map_to_mich(fp.name, fp.type.key_type, fp.type.value_type, ci);
        case "nat": return class_to_mich(typescript_1.factory.createIdentifier(fp.name));
        case "never": return throw_error(fp.type.node);
        case "operation": return throw_error(fp.type.node);
        case "option": return option_to_mich(fp.type.arg, typescript_1.factory.createIdentifier(fp.name));
        case "or": return or_to_mich(fp.type.left_type, fp.type.right_type, typescript_1.factory.createIdentifier(fp.name));
        case "partition": return list_to_mich(fp.name, { node: "asset_key", name: fp.type.name }, ci);
        case "rational": return class_to_mich(typescript_1.factory.createIdentifier(fp.name));
        case "record": return class_to_mich(typescript_1.factory.createIdentifier(fp.name));
        case "sapling_state": return class_to_mich(typescript_1.factory.createIdentifier(fp.name));
        case "sapling_transaction": return class_to_mich(typescript_1.factory.createIdentifier(fp.name));
        case "set": return list_to_mich(fp.name, fp.type.arg, ci);
        case "signature": return class_to_mich(typescript_1.factory.createIdentifier(fp.name));
        case "state": return throw_error(fp.type.node);
        case "string": return string_to_mich(typescript_1.factory.createIdentifier(fp.name));
        case "ticket": return ticket_to_mich(fp.type.arg, typescript_1.factory.createIdentifier(fp.name));
        case "timestamp": return throw_error(fp.type.node);
        case "tuple": return tuple_to_mich(fp.name, fp.type.args, ci);
        case "unit": return (0, exports.unit_to_mich)();
    }
};
exports.function_param_to_mich = function_param_to_mich;
const function_params_to_mich = (a, ci) => {
    if (a.length == 0) {
        return typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("unit_mich"));
    }
    else if (a.length == 1) {
        return (0, exports.function_param_to_mich)(a[0], ci);
    }
    else {
        return typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("pair_to_mich")), undefined, [typescript_1.factory.createArrayLiteralExpression(a.map((x, i) => (0, exports.function_param_to_mich)(x, ci)), true)]);
    }
};
exports.function_params_to_mich = function_params_to_mich;
const storage_to_mich = (mt, selts, ci) => {
    if (mt.prim == "pair" && mt.annots && mt.annots.length == 0) {
        return typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("pair_to_mich")), undefined, [typescript_1.factory.createArrayLiteralExpression(mt.args.map(x => (0, exports.storage_to_mich)(x, selts, ci)), false)]);
    }
    else {
        let selt = selts[0];
        if (mt.annots && mt.annots.length > 0) {
            const annot = mt.annots[0];
            for (let i = 0; i < selts.length; i++) {
                if (annot == "%" + selts[i].name) {
                    selt = selts[i];
                }
            }
        }
        return (0, exports.function_param_to_mich)(selt, ci);
    }
};
exports.storage_to_mich = storage_to_mich;
const get_archetype_type_from_idx = (idx, fields) => {
    return fields[idx].type;
};
const get_field_name_from_idx = (idx, fields) => {
    return fields[idx].name;
};
const mich_type_to_archetype = (mt) => {
    switch (mt.prim) {
        case "address": return { node: mt.prim };
        case "big_map": return { node: mt.prim, key_type: mich_type_to_archetype(mt.args[0]), value_type: mich_type_to_archetype(mt.args[1]) };
        case "bls12_381_fr": return { node: mt.prim };
        case "bls12_381_g1": return { node: mt.prim };
        case "bls12_381_g2": return { node: mt.prim };
        case "bool": return { node: mt.prim };
        case "bytes": return { node: mt.prim };
        case "chain_id": return { node: mt.prim };
        case "chest_key": return { node: mt.prim };
        case "chest": return { node: mt.prim };
        case "contract": return { node: mt.prim, arg: mich_type_to_archetype(mt.args[0]) };
        case "int": return { node: mt.prim };
        case "key_hash": return { node: mt.prim };
        case "key": return { node: mt.prim };
        case "lambda": return { node: mt.prim, arg_type: mich_type_to_archetype(mt.args[0]), ret_type: mich_type_to_archetype(mt.args[1]) };
        case "list": return { node: mt.prim, arg: mich_type_to_archetype(mt.args[0]) };
        case "map": return { node: mt.prim, key_type: mich_type_to_archetype(mt.args[0]), value_type: mich_type_to_archetype(mt.args[1]) };
        case "mutez": return { node: "currency" };
        case "nat": return { node: mt.prim };
        case "never": return { node: mt.prim };
        case "operation": return { node: mt.prim };
        case "option": return { node: mt.prim, arg: mich_type_to_archetype(mt.args[0]) };
        case "or": return { node: mt.prim, left_type: mich_type_to_archetype(mt.args[0]), right_type: mich_type_to_archetype(mt.args[1]) };
        case "pair": return { node: "tuple", args: mt.args.map(mich_type_to_archetype) };
        case "sapling_state": return { node: mt.prim, memo_size: parseInt(mt.args[0].int) };
        case "sapling_transaction": return { node: mt.prim, memo_size: parseInt(mt.args[0].int) };
        case "set": return { node: mt.prim, arg: mich_type_to_archetype(mt.args[0]) };
        case "signature": return { node: mt.prim };
        case "string": return { node: mt.prim };
        case "ticket": return { node: mt.prim, arg: mich_type_to_archetype(mt.args[0]) };
        case "timestamp": return { node: "date" };
        case "unit": return { node: mt.prim };
        // default: throw new Error("mich_type_to_archetype: cannot convert prim '" + (mt.prim ?? "null") + "'")
    }
};
/**
 * Generates To Michelson TS expression that follows its Michelson Type structure
 * @param v value name
 * @param mt local michelson type
 * @param fields base of fields for type lookup
 * @param fidx field index
 * @returns pair of number of fields looked up so far and 'to_mich' expression
 */
const entity_to_mich = (v, mt, fields, fidx = 0, ci) => {
    var _a;
    if (mt.annots && mt.annots.length > 0) {
        //const name = mt.annots[0].slice(1)
        const name = get_field_name_from_idx(fidx, fields);
        //const atype = get_archetype_type_of(name, fields)
        const atype = get_archetype_type_from_idx(fidx, fields);
        if (undefined == atype) {
            throw new Error("entity_to_mich: type not found for '" + (name !== null && name !== void 0 ? name : "null") + "'");
        }
        if (name == null) {
            throw new Error("entity_to_mich: field name is null");
        }
        const fp = { name: v + "." + name, type: atype };
        return [fidx + 1, (0, exports.function_param_to_mich)(fp, ci)];
    }
    else {
        switch (mt.prim) {
            case "pair": {
                if (fields.length == 1 && ((_a = fields[0].type) === null || _a === void 0 ? void 0 : _a.node) == "record") {
                    return [fidx, (0, exports.function_param_to_mich)({ name: v, type: mich_type_to_archetype(mt) }, ci)];
                }
                else {
                    const lexpr = [];
                    const [fidx00, llexpr] = mt.args.reduce(([idx, lexpr], arg) => {
                        const [fidx0, expr] = (0, exports.entity_to_mich)(v, arg, fields, idx, ci);
                        lexpr.push(expr);
                        return [fidx0, lexpr];
                    }, ([fidx, lexpr]));
                    return [fidx00, typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("pair_to_mich")), undefined, [typescript_1.factory.createArrayLiteralExpression(llexpr, false)])];
                }
            }
            case "map":
            case "big_map": {
                // left
                const [_, expr0] = (0, exports.entity_to_mich)("x_key", mt.args[0], fields.filter(x => x.is_key), fidx, ci);
                // right
                const [fidx1, expr1] = (0, exports.entity_to_mich)("x_value", mt.args[1], fields.filter(x => !x.is_key), fidx, ci);
                return [fidx1, internal_map_to_mich(v, [
                        expr0,
                        expr1
                    ])];
            }
            case "set": {
                const [_, expr0] = (0, exports.entity_to_mich)("x", mt.args[0], fields.filter(x => x.is_key), fidx, ci);
                return [fidx, internal_list_to_mich(v, [
                        typescript_1.factory.createReturnStatement(expr0)
                    ])
                ];
            }
            default: return [fidx, (0, exports.function_param_to_mich)({ name: v, type: mich_type_to_archetype(mt) }, ci)];
        }
    }
};
exports.entity_to_mich = entity_to_mich;
const value_to_mich_type = (mt) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
    const for_composite_type = (arg) => {
        const annots = mt.annots ? (mt.annots.length >= 1 ? [typescript_1.factory.createStringLiteral(mt.annots[0])] : []) : [];
        return typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("list_annot_to_mich_type")), undefined, [
            (0, exports.value_to_mich_type)(arg),
            typescript_1.factory.createArrayLiteralExpression(annots, false)
        ]);
    };
    const for_set_type = (arg) => {
        const annots = mt.annots ? (mt.annots.length >= 1 ? [typescript_1.factory.createStringLiteral(mt.annots[0])] : []) : [];
        return typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("set_annot_to_mich_type")), undefined, [
            (0, exports.value_to_mich_type)(arg),
            typescript_1.factory.createArrayLiteralExpression(annots, false)
        ]);
    };
    const for_simple_type = (prim, annots) => {
        const exprAnnots = annots.length >= 1 ? [typescript_1.factory.createStringLiteral(annots[0])] : [];
        return typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("prim_annot_to_mich_type")), undefined, [
            typescript_1.factory.createStringLiteral(prim),
            typescript_1.factory.createArrayLiteralExpression(exprAnnots, false)
        ]);
    };
    const for_lambda = (annots, arg_left, arg_right) => {
        const exprAnnots = annots.length >= 1 ? [typescript_1.factory.createStringLiteral(annots[0])] : [];
        return typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("pair_annot_to_mich_type")), undefined, [
            typescript_1.factory.createStringLiteral("lambda"),
            (0, exports.value_to_mich_type)(arg_left),
            (0, exports.value_to_mich_type)(arg_right),
            typescript_1.factory.createArrayLiteralExpression(exprAnnots, false)
        ]);
    };
    switch (mt.prim) {
        case "address": return for_simple_type(mt.prim, (_a = mt.annots) !== null && _a !== void 0 ? _a : []);
        case "big_map": {
            const annots = mt.annots && mt.annots.length >= 1 ? [typescript_1.factory.createStringLiteral(mt.annots[0])] : [];
            return typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("pair_annot_to_mich_type")), undefined, [
                typescript_1.factory.createStringLiteral("big_map"),
                (0, exports.value_to_mich_type)(mt.args[0]), (0, exports.value_to_mich_type)(mt.args[1]), typescript_1.factory.createArrayLiteralExpression(annots, false)
            ]);
        }
        case "bls12_381_fr": return for_simple_type(mt.prim, (_b = mt.annots) !== null && _b !== void 0 ? _b : []);
        case "bls12_381_g1": return for_simple_type(mt.prim, (_c = mt.annots) !== null && _c !== void 0 ? _c : []);
        case "bls12_381_g2": return for_simple_type(mt.prim, (_d = mt.annots) !== null && _d !== void 0 ? _d : []);
        case "bool": return for_simple_type(mt.prim, (_e = mt.annots) !== null && _e !== void 0 ? _e : []);
        case "bytes": return for_simple_type(mt.prim, (_f = mt.annots) !== null && _f !== void 0 ? _f : []);
        case "chain_id": return for_simple_type(mt.prim, (_g = mt.annots) !== null && _g !== void 0 ? _g : []);
        case "chest_key": return for_simple_type(mt.prim, (_h = mt.annots) !== null && _h !== void 0 ? _h : []);
        case "chest": return for_simple_type(mt.prim, (_j = mt.annots) !== null && _j !== void 0 ? _j : []);
        case "contract": {
            const annots = mt.annots ? (mt.annots.length >= 1 ? [typescript_1.factory.createStringLiteral(mt.annots[0])] : []) : [];
            return typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("contract_annot_to_mich_type")), undefined, [
                (0, exports.value_to_mich_type)(mt.args[0]),
                typescript_1.factory.createArrayLiteralExpression(annots, false)
            ]);
        }
        case "int": return for_simple_type(mt.prim, (_k = mt.annots) !== null && _k !== void 0 ? _k : []);
        case "key_hash": return for_simple_type(mt.prim, (_l = mt.annots) !== null && _l !== void 0 ? _l : []);
        case "key": return for_simple_type(mt.prim, (_m = mt.annots) !== null && _m !== void 0 ? _m : []);
        case "lambda": return for_lambda((_o = mt.annots) !== null && _o !== void 0 ? _o : [], mt.args[0], mt.args[1]);
        case "list": return for_composite_type(mt.args[0]);
        case "map": {
            const annots = mt.annots && mt.annots.length >= 1 ? [typescript_1.factory.createStringLiteral(mt.annots[0])] : [];
            return typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("pair_annot_to_mich_type")), undefined, [
                typescript_1.factory.createStringLiteral("map"),
                (0, exports.value_to_mich_type)(mt.args[0]), (0, exports.value_to_mich_type)(mt.args[1]), typescript_1.factory.createArrayLiteralExpression(annots, false)
            ]);
        }
        case "mutez": return for_simple_type(mt.prim, (_p = mt.annots) !== null && _p !== void 0 ? _p : []);
        case "nat": return for_simple_type(mt.prim, (_q = mt.annots) !== null && _q !== void 0 ? _q : []);
        case "never": return for_simple_type(mt.prim, (_r = mt.annots) !== null && _r !== void 0 ? _r : []);
        case "operation": return for_simple_type(mt.prim, (_s = mt.annots) !== null && _s !== void 0 ? _s : []);
        case "option": {
            const annots = mt.annots ? (mt.annots.length >= 1 ? [typescript_1.factory.createStringLiteral(mt.annots[0])] : []) : [];
            return typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("option_annot_to_mich_type")), undefined, [
                (0, exports.value_to_mich_type)(mt.args[0]),
                typescript_1.factory.createArrayLiteralExpression(annots, false)
            ]);
        }
        case "or": return typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("or_to_mich_type")), undefined, [
            (0, exports.value_to_mich_type)(mt.args[0]),
            (0, exports.value_to_mich_type)(mt.args[1]),
            typescript_1.factory.createArrayLiteralExpression(mt.annots ? mt.annots.map(a => typescript_1.factory.createStringLiteral(a, false)) : [])
        ]);
        case "pair": {
            const annots = mt.annots && mt.annots.length >= 1 ? [typescript_1.factory.createStringLiteral(mt.annots[0])] : [];
            return typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("pair_array_to_mich_type")), undefined, [
                typescript_1.factory.createArrayLiteralExpression(mt.args.map(exports.value_to_mich_type), 
                // [value_to_mich_type(mt.args[0]), value_to_mich_type(mt.args[1])],
                true),
                typescript_1.factory.createArrayLiteralExpression(annots, false)
            ]);
        }
        case "ticket": {
            const annots = mt.annots && mt.annots.length >= 1 ? [typescript_1.factory.createStringLiteral(mt.annots[0])] : [];
            return typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("ticket_annot_to_mich_type")), undefined, [
                (0, exports.value_to_mich_type)(mt.args[0]),
                typescript_1.factory.createArrayLiteralExpression(annots, false)
            ]);
        }
        case "sapling_state": return for_simple_type(mt.prim, (_t = mt.annots) !== null && _t !== void 0 ? _t : []);
        case "sapling_transaction": return for_simple_type(mt.prim, (_u = mt.annots) !== null && _u !== void 0 ? _u : []);
        case "set": return for_set_type(mt.args[0]);
        case "signature": return for_simple_type(mt.prim, (_v = mt.annots) !== null && _v !== void 0 ? _v : []);
        case "string": return for_simple_type(mt.prim, (_w = mt.annots) !== null && _w !== void 0 ? _w : []);
        case "ticket": return for_simple_type(mt.prim, (_x = mt.annots) !== null && _x !== void 0 ? _x : []);
        case "timestamp": return for_simple_type(mt.prim, (_y = mt.annots) !== null && _y !== void 0 ? _y : []);
        case "unit": return for_simple_type(mt.prim, (_z = mt.annots) !== null && _z !== void 0 ? _z : []);
    }
};
exports.value_to_mich_type = value_to_mich_type;
/* Errors ------------------------------------------------------------------ */
const to_label = (input) => {
    const res = input.replace(/^\d/g, "_").split(new RegExp("[ !\"#$%&'()*+,-./:;<=>?@\[\\\]^`{}~]")).join('_').toUpperCase();
    return res;
};
exports.to_label = to_label;
const mich_type_to_error = (expr) => {
    if (expr && expr.string) {
        return [(0, exports.to_label)(expr.string), typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("string_to_mich")), undefined, [typescript_1.factory.createStringLiteral("\"" + expr.string + "\"")])];
    }
    else if (expr && expr.prim == "Pair") {
        const args = expr.args.reduce((acc, x) => {
            const res = (0, exports.mich_type_to_error)(x);
            if (res != null) {
                acc.push(res);
                return acc;
            }
            else {
                return acc;
            }
        }, []);
        const label = args.reduce((acc, n) => {
            return (acc == "" ? "" : acc + "_") + n[0].toUpperCase();
        }, "");
        return [label, typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("pair_to_mich")), undefined, [typescript_1.factory.createArrayLiteralExpression(args.map(p => p[1]))])];
    }
    else {
        return null;
    }
};
exports.mich_type_to_error = mich_type_to_error;
const make_error = (error) => {
    switch (error.kind) {
        case "InvalidCondition":
            const res = (0, exports.mich_type_to_error)(error.expr);
            return res ? [error.args[0], res[1]] : null;
        default:
            return (0, exports.mich_type_to_error)(error.expr);
    }
};
exports.make_error = make_error;
/* constant code functions */
const make_to_string_decl = () => {
    return typescript_1.factory.createMethodDeclaration(undefined, undefined, undefined, typescript_1.factory.createIdentifier("toString"), undefined, undefined, [], typescript_1.factory.createKeywordTypeNode(typescript_1.default.SyntaxKind.StringKeyword), typescript_1.factory.createBlock([typescript_1.factory.createReturnStatement(typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier("JSON"), typescript_1.factory.createIdentifier("stringify")), undefined, [
            typescript_1.factory.createThis(),
            typescript_1.factory.createNull(),
            typescript_1.factory.createNumericLiteral("2")
        ]))], true));
};
exports.make_to_string_decl = make_to_string_decl;
// class utils
const get_constructor = () => {
    return typescript_1.factory.createConstructorDeclaration(undefined, undefined, [typescript_1.factory.createParameterDeclaration(undefined, undefined, undefined, typescript_1.factory.createIdentifier("address"), undefined, typescript_1.factory.createUnionTypeNode([
            typescript_1.factory.createKeywordTypeNode(typescript_1.default.SyntaxKind.StringKeyword),
            typescript_1.factory.createKeywordTypeNode(typescript_1.default.SyntaxKind.UndefinedKeyword)
        ]), typescript_1.factory.createIdentifier("undefined"))], typescript_1.factory.createBlock([typescript_1.factory.createExpressionStatement(typescript_1.factory.createBinaryExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createThis(), typescript_1.factory.createIdentifier("address")), typescript_1.factory.createToken(typescript_1.default.SyntaxKind.EqualsToken), typescript_1.factory.createIdentifier("address")))], true));
};
exports.get_constructor = get_constructor;
const get_get_address_decl = () => {
    return typescript_1.factory.createMethodDeclaration(undefined, undefined, undefined, typescript_1.factory.createIdentifier("get_address"), undefined, undefined, [], typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createQualifiedName(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("Address")), undefined), typescript_1.factory.createBlock([
        typescript_1.factory.createIfStatement(typescript_1.factory.createBinaryExpression(typescript_1.factory.createIdentifier("undefined"), typescript_1.factory.createToken(typescript_1.default.SyntaxKind.ExclamationEqualsToken), typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createThis(), typescript_1.factory.createIdentifier("address"))), typescript_1.factory.createBlock([typescript_1.factory.createReturnStatement(typescript_1.factory.createNewExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("Address")), undefined, [typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createThis(), typescript_1.factory.createIdentifier("address"))]))], true), undefined),
        typescript_1.factory.createThrowStatement(typescript_1.factory.createNewExpression(typescript_1.factory.createIdentifier("Error"), undefined, [typescript_1.factory.createStringLiteral("Contract not initialised")]))
    ], true));
};
exports.get_get_address_decl = get_get_address_decl;
const get_get_balance_decl = () => {
    return typescript_1.factory.createMethodDeclaration(undefined, [typescript_1.factory.createModifier(typescript_1.default.SyntaxKind.AsyncKeyword)], undefined, typescript_1.factory.createIdentifier("get_balance"), undefined, undefined, [], typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createIdentifier("Promise"), [typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createQualifiedName(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("Tez")), undefined)]), typescript_1.factory.createBlock([
        typescript_1.factory.createIfStatement(typescript_1.factory.createBinaryExpression(typescript_1.factory.createNull(), typescript_1.factory.createToken(typescript_1.default.SyntaxKind.ExclamationEqualsToken), typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createThis(), typescript_1.factory.createIdentifier("address"))), typescript_1.factory.createBlock([typescript_1.factory.createReturnStatement(typescript_1.factory.createAwaitExpression(typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier("ex"), typescript_1.factory.createIdentifier("get_balance")), undefined, [typescript_1.factory.createNewExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier("att"), typescript_1.factory.createIdentifier("Address")), undefined, [typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createThis(), typescript_1.factory.createIdentifier("address"))])])))], true), undefined),
        typescript_1.factory.createThrowStatement(typescript_1.factory.createNewExpression(typescript_1.factory.createIdentifier("Error"), undefined, [typescript_1.factory.createStringLiteral("Contract not initialised")]))
    ], true));
};
exports.get_get_balance_decl = get_get_balance_decl;
const raw_to_contract_interface = (rci) => {
    const replace_keyword = (input) => {
        if (input == "default") {
            return "$" + input;
        }
        return input;
    };
    const to_archetype_type = (rty) => {
        const force_name = (i) => {
            if (i == null) {
                throw new Error("Invalid name");
            }
            else {
                return i;
            }
        };
        const force_int_value = (i) => {
            if (i == null) {
                throw new Error("Invalid int_value");
            }
            else {
                return i;
            }
        };
        switch (rty.node) {
            case "address": return { node: rty.node };
            case "aggregate": return { node: rty.node, name: force_name(rty.name) };
            case "asset_container": return { node: rty.node, name: force_name(rty.name) };
            case "asset_key": return { node: rty.node, name: force_name(rty.name) };
            case "asset_value": return { node: rty.node, name: force_name(rty.name) };
            case "asset_view": return { node: rty.node, name: force_name(rty.name) };
            case "asset": return { node: rty.node, name: force_name(rty.name) };
            case "big_map": return { node: rty.node, key_type: to_archetype_type(rty.args[0]), value_type: to_archetype_type(rty.args[1]) };
            case "bls12_381_fr": return { node: rty.node };
            case "bls12_381_g1": return { node: rty.node };
            case "bls12_381_g2": return { node: rty.node };
            case "bool": return { node: rty.node };
            case "bytes": return { node: rty.node };
            case "chain_id": return { node: rty.node };
            case "chest_key": return { node: rty.node };
            case "chest": return { node: rty.node };
            case "collection": return { node: rty.node, name: force_name(rty.name) };
            case "contract": return { node: rty.node, arg: to_archetype_type(rty.args[0]) };
            case "currency": return { node: rty.node };
            case "date": return { node: rty.node };
            case "duration": return { node: rty.node };
            case "enum": return { node: rty.node, name: force_name(rty.name) };
            case "event": return { node: rty.node, name: force_name(rty.name) };
            case "int": return { node: rty.node };
            case "iterable_big_map": return { node: rty.node, key_type: to_archetype_type(rty.args[0]), value_type: to_archetype_type(rty.args[1]) };
            case "key_hash": return { node: rty.node };
            case "key": return { node: rty.node };
            case "lambda": return { node: rty.node, arg_type: to_archetype_type(rty.args[0]), ret_type: to_archetype_type(rty.args[1]) };
            case "list": return { node: rty.node, arg: to_archetype_type(rty.args[0]) };
            case "map": return { node: rty.node, key_type: to_archetype_type(rty.args[0]), value_type: to_archetype_type(rty.args[1]) };
            case "nat": return { node: rty.node };
            case "never": return { node: rty.node };
            case "operation": return { node: rty.node };
            case "option": return { node: rty.node, arg: to_archetype_type(rty.args[0]) };
            case "or": return { node: rty.node, left_type: to_archetype_type(rty.args[0]), right_type: to_archetype_type(rty.args[1]) };
            case "partition": return { node: rty.node, name: force_name(rty.name) };
            case "rational": return { node: rty.node };
            case "record": return { node: rty.node, name: force_name(rty.name) };
            case "sapling_state": return { node: rty.node, memo_size: force_int_value(rty.int_value) };
            case "sapling_transaction": return { node: rty.node, memo_size: force_int_value(rty.int_value) };
            case "set": return { node: rty.node, arg: to_archetype_type(rty.args[0]) };
            case "signature": return { node: rty.node };
            case "state": return { node: rty.node };
            case "string": return { node: rty.node };
            case "ticket": return { node: rty.node, arg: to_archetype_type(rty.args[0]) };
            case "timestamp": return { node: rty.node };
            case "tuple": return { node: rty.node, args: rty.args.map(to_archetype_type) };
            case "unit": return { node: rty.node };
        }
    };
    const to_michelson_type = (rty) => {
        var _a;
        switch (rty.prim) {
            case "address": return { prim: rty.prim, annots: rty.annots };
            case "big_map": return { prim: rty.prim, annots: rty.annots, args: [to_michelson_type(rty.args[0]), to_michelson_type(rty.args[1])] };
            case "bls12_381_fr": return { prim: rty.prim, annots: rty.annots };
            case "bls12_381_g1": return { prim: rty.prim, annots: rty.annots };
            case "bls12_381_g2": return { prim: rty.prim, annots: rty.annots };
            case "bool": return { prim: rty.prim, annots: rty.annots };
            case "bytes": return { prim: rty.prim, annots: rty.annots };
            case "chain_id": return { prim: rty.prim, annots: rty.annots };
            case "chest_key": return { prim: rty.prim, annots: rty.annots };
            case "chest": return { prim: rty.prim, annots: rty.annots };
            case "contract": return { prim: rty.prim, annots: rty.annots, args: [to_michelson_type(rty.args[0])] };
            case "int": return { prim: rty.prim, annots: rty.annots };
            case "key_hash": return { prim: rty.prim, annots: rty.annots };
            case "key": return { prim: rty.prim, annots: rty.annots };
            case "lambda": return { prim: rty.prim, annots: rty.annots, args: [to_michelson_type(rty.args[0]), to_michelson_type(rty.args[1])] };
            case "list": return { prim: rty.prim, annots: rty.annots, args: [to_michelson_type(rty.args[0])] };
            case "map": return { prim: rty.prim, annots: rty.annots, args: [to_michelson_type(rty.args[0]), to_michelson_type(rty.args[1])] };
            case "mutez": return { prim: rty.prim, annots: rty.annots };
            case "nat": return { prim: rty.prim, annots: rty.annots };
            case "never": return { prim: rty.prim, annots: rty.annots };
            case "operation": return { prim: rty.prim, annots: rty.annots };
            case "option": return { prim: rty.prim, annots: rty.annots, args: [to_michelson_type(rty.args[0])] };
            case "or": return { prim: rty.prim, annots: rty.annots, args: [to_michelson_type(rty.args[0]), to_michelson_type(rty.args[1])] };
            case "pair": return { prim: rty.prim, annots: rty.annots, args: rty.args.map(to_michelson_type) };
            case "sapling_state": return { prim: rty.prim, annots: rty.annots, args: [{ int: rty.args[0].int }] };
            case "sapling_transaction": return { prim: rty.prim, annots: rty.annots, args: [{ int: rty.args[0].int }] };
            case "set": return { prim: rty.prim, annots: rty.annots, args: [to_michelson_type(rty.args[0])] };
            case "signature": return { prim: rty.prim, annots: rty.annots };
            case "string": return { prim: rty.prim, annots: rty.annots };
            case "ticket": return { prim: rty.prim, annots: rty.annots, args: [to_michelson_type(rty.args[0])] };
            case "timestamp": return { prim: rty.prim, annots: rty.annots };
            case "unit": return { prim: rty.prim, annots: rty.annots };
            default: throw new Error(`to_michelson_type: Invalid type ${(_a = rty.prim) !== null && _a !== void 0 ? _a : "null"}`);
        }
    };
    const to_michelson_data = (rd) => {
        var _a;
        if (rd.string) {
            return { string: rd.string };
        }
        else if (rd.int) {
            return { int: rd.int };
        }
        else if (rd.bytes) {
            return { bytes: rd.bytes };
        }
        else if (rd.prim) {
            switch (rd.prim) {
                case "Elt": return { prim: rd.prim, args: [to_michelson_data(rd.args[0]), to_michelson_data(rd.args[1])] };
                case "False": return { prim: rd.prim };
                case "Left": return { prim: rd.prim, args: [to_michelson_data(rd.args[0])] };
                case "None": return { prim: rd.prim };
                case "Pair": return { prim: rd.prim, args: rd.args.map(to_michelson_data) };
                case "Right": return { prim: rd.prim, args: [to_michelson_data(rd.args[0])] };
                case "Some": return { prim: rd.prim, args: [to_michelson_data(rd.args[0])] };
                case "True": return { prim: rd.prim };
                case "Unit": return { prim: rd.prim };
                default: throw new Error(`to_michelson_data: Invalid data ${(_a = rd.prim) !== null && _a !== void 0 ? _a : "null"}`);
            }
        }
        else {
            return (rd.array.map(to_michelson_data));
        }
    };
    const to_michelson_type_is_storable = (i) => {
        return { value: to_michelson_type(i.value), is_storable: i.is_storable };
    };
    const for_field = (i) => {
        return Object.assign(Object.assign({}, i), { "type": to_archetype_type(i.type) });
    };
    const for_field_omit = (i) => {
        return Object.assign(Object.assign({}, i), { "type": to_archetype_type(i.type) });
    };
    const for_function_parameter = (i) => {
        return Object.assign(Object.assign({}, i), { "type": to_archetype_type(i.type) });
    };
    return {
        "name": rci.name,
        "parameters": rci.parameters.map((i) => { return Object.assign(Object.assign({}, i), { "type": to_archetype_type(i.type) }); }),
        "types": {
            assets: rci.types.assets.map((i) => {
                return Object.assign(Object.assign({}, i), { "fields": i.fields.map(for_field), "container_type_michelson": to_michelson_type(i.container_type_michelson), "key_type_michelson": to_michelson_type(i.key_type_michelson), "value_type_michelson": to_michelson_type(i.value_type_michelson) });
            }),
            enums: rci.types.enums.map((i) => {
                return Object.assign(Object.assign({}, i), { "constructors": i.constructors.map((i) => { return Object.assign(Object.assign({}, i), { "types": i.types.map(to_archetype_type) }); }), "type_michelson": to_michelson_type(i.type_michelson) });
            }),
            records: rci.types.records.map((i) => {
                return Object.assign(Object.assign({}, i), { "fields": i.fields.map(for_field_omit), "type_michelson": to_michelson_type(i.type_michelson) });
            }),
            events: rci.types.events.map((i) => {
                return Object.assign(Object.assign({}, i), { "fields": i.fields.map(for_field_omit), "type_michelson": to_michelson_type(i.type_michelson) });
            }),
        },
        storage: rci.storage.map((i) => {
            return Object.assign(Object.assign({}, i), { "name": replace_keyword(i.name), "type": to_archetype_type(i.type) });
        }),
        storage_type: to_michelson_type_is_storable(rci.storage_type),
        entrypoints: rci.entrypoints.map((i) => {
            return Object.assign(Object.assign({}, i), { "args": i.args.map(for_function_parameter) });
        }),
        getters: rci.getters.map((i) => {
            return Object.assign(Object.assign({}, i), { "args": i.args.map(for_function_parameter), "return": to_archetype_type(i.return), "return_michelson": to_michelson_type_is_storable(i.return_michelson) });
        }),
        views: rci.views.map((i) => { return Object.assign(Object.assign({}, i), { "args": i.args.map(for_function_parameter), "return": to_archetype_type(i.return) }); }),
        errors: rci.errors.map(x => { return Object.assign(Object.assign({}, x), { expr: to_michelson_data(x.expr) }); })
    };
};
exports.raw_to_contract_interface = raw_to_contract_interface;
const to_michelson_type = (rmt) => {
    var _a;
    switch (rmt.prim) {
        case "address": return { prim: rmt.prim, annots: rmt.annots };
        case "big_map": return { prim: rmt.prim, annots: rmt.annots, args: [(0, exports.to_michelson_type)(rmt.args[0]), (0, exports.to_michelson_type)(rmt.args[1])] };
        case "bls12_381_fr": return { prim: rmt.prim, annots: rmt.annots };
        case "bls12_381_g1": return { prim: rmt.prim, annots: rmt.annots };
        case "bls12_381_g2": return { prim: rmt.prim, annots: rmt.annots };
        case "bool": return { prim: rmt.prim, annots: rmt.annots };
        case "bytes": return { prim: rmt.prim, annots: rmt.annots };
        case "chain_id": return { prim: rmt.prim, annots: rmt.annots };
        case "chest_key": return { prim: rmt.prim, annots: rmt.annots };
        case "chest": return { prim: rmt.prim, annots: rmt.annots };
        case "contract": return { prim: rmt.prim, annots: rmt.annots, args: [(0, exports.to_michelson_type)(rmt.args[0])] };
        case "int": return { prim: rmt.prim, annots: rmt.annots };
        case "key_hash": return { prim: rmt.prim, annots: rmt.annots };
        case "key": return { prim: rmt.prim, annots: rmt.annots };
        case "lambda": return { prim: rmt.prim, annots: rmt.annots, args: [(0, exports.to_michelson_type)(rmt.args[0]), (0, exports.to_michelson_type)(rmt.args[1])] };
        case "list": return { prim: rmt.prim, annots: rmt.annots, args: [(0, exports.to_michelson_type)(rmt.args[0])] };
        case "map": return { prim: rmt.prim, annots: rmt.annots, args: [(0, exports.to_michelson_type)(rmt.args[0]), (0, exports.to_michelson_type)(rmt.args[1])] };
        case "mutez": return { prim: rmt.prim, annots: rmt.annots };
        case "nat": return { prim: rmt.prim, annots: rmt.annots };
        case "never": return { prim: rmt.prim, annots: rmt.annots };
        case "operation": return { prim: rmt.prim, annots: rmt.annots };
        case "option": return { prim: rmt.prim, annots: rmt.annots, args: [(0, exports.to_michelson_type)(rmt.args[0])] };
        case "or": return { prim: rmt.prim, annots: rmt.annots, args: [(0, exports.to_michelson_type)(rmt.args[0]), (0, exports.to_michelson_type)(rmt.args[1])] };
        case "pair": return { prim: rmt.prim, annots: rmt.annots, args: rmt.args.map(exports.to_michelson_type) };
        case "sapling_state": {
            if (rmt.args[0].int == null) {
                throw new Error("to_michelson_type: Invalid sapling_state");
            }
            return { prim: rmt.prim, annots: rmt.annots, args: [{ int: rmt.args[0].int }] };
        }
        case "sapling_transaction": {
            if (rmt.args[0].int == null) {
                throw new Error("to_michelson_type: Invalid sapling_transaction");
            }
            return { prim: rmt.prim, annots: rmt.annots, args: [{ int: rmt.args[0].int }] };
        }
        case "set": return { prim: rmt.prim, annots: rmt.annots, args: [(0, exports.to_michelson_type)(rmt.args[0])] };
        case "signature": return { prim: rmt.prim, annots: rmt.annots };
        case "string": return { prim: rmt.prim, annots: rmt.annots };
        case "ticket": return { prim: rmt.prim, annots: rmt.annots, args: [(0, exports.to_michelson_type)(rmt.args[0])] };
        case "timestamp": return { prim: rmt.prim, annots: rmt.annots };
        case "unit": return { prim: rmt.prim, annots: rmt.annots };
        default: throw new Error(`to_michelson_type: Invalid type ${(_a = rmt.prim) !== null && _a !== void 0 ? _a : "null"}`);
    }
};
exports.to_michelson_type = to_michelson_type;
//# sourceMappingURL=utils.js.map
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@taquito/http-utils'), require('bignumber.js'), require('@taquito/utils'), require('@taquito/core')) :
    typeof define === 'function' && define.amd ? define(['exports', '@taquito/http-utils', 'bignumber.js', '@taquito/utils', '@taquito/core'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.taquitoRpc = {}, global.httpUtils, global.BigNumber, global.utils, global.core));
})(this, (function (exports, httpUtils, BigNumber, utils, core) { 'use strict';

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise, SuppressedError, Symbol */


    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
        var e = new Error(message);
        return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };

    const defaultChain = 'main';
    const defaultRPCOptions = { block: 'head' };
    var RPCMethodName;
    (function (RPCMethodName) {
        RPCMethodName["GET_BAKING_RIGHTS"] = "getBakingRights";
        RPCMethodName["GET_BALLOTS"] = "getBallots";
        RPCMethodName["GET_BALLOT_LIST"] = "getBallotList";
        RPCMethodName["GET_BIG_MAP_KEY"] = "getBigMapKey";
        RPCMethodName["GET_BIG_MAP_EXPR"] = "getBigMapExpr";
        RPCMethodName["GET_BLOCK_HASH"] = "getBlockHash";
        RPCMethodName["GET_BLOCK"] = "getBlock";
        RPCMethodName["GET_BLOCK_HEADER"] = "getBlockHeader";
        RPCMethodName["GET_BLOCK_METADATA"] = "getBlockMetadata";
        RPCMethodName["GET_BALANCE"] = "getBalance";
        RPCMethodName["GET_CHAIN_ID"] = "getChainId";
        RPCMethodName["GET_CONSTANTS"] = "getConstants";
        RPCMethodName["GET_CONTRACT"] = "getContract";
        RPCMethodName["GET_CURRENT_PERIOD"] = "getCurrentPeriod";
        RPCMethodName["GET_CURRENT_PROPOSAL"] = "getCurrentProposal";
        RPCMethodName["GET_CURRENT_QUORUM"] = "getCurrentQuorum";
        RPCMethodName["GET_DELEGATE"] = "getDelegate";
        RPCMethodName["GET_DELEGATES"] = "getDelegates";
        RPCMethodName["GET_VOTING_INFO"] = "getVotingInfo";
        RPCMethodName["GET_ATTESTATION_RIGHTS"] = "getAttestationRights";
        RPCMethodName["GET_ENDORSING_RIGHTS"] = "getEndorsingRights";
        RPCMethodName["GET_ENTRYPOINTS"] = "getEntrypoints";
        RPCMethodName["GET_LIVE_BLOCKS"] = "getLiveBlocks";
        RPCMethodName["GET_MANAGER_KEY"] = "getManagerKey";
        RPCMethodName["GET_NORMALIZED_SCRIPT"] = "getNormalizedScript";
        RPCMethodName["GET_PROPOSALS"] = "getProposals";
        RPCMethodName["GET_PROTOCOLS"] = "getProtocols";
        RPCMethodName["GET_SAPLING_DIFF_BY_CONTRACT"] = "getSaplingDiffByContract";
        RPCMethodName["GET_SAPLING_DIFF_BY_ID"] = "getSaplingDiffById";
        RPCMethodName["GET_SCRIPT"] = "getScript";
        RPCMethodName["GET_STORAGE"] = "getStorage";
        RPCMethodName["GET_SUCCESSOR_PERIOD"] = "getSuccessorPeriod";
        RPCMethodName["GET_VOTES_LISTINGS"] = "getVotesListings";
        RPCMethodName["PACK_DATA"] = "packData";
        RPCMethodName["GET_STORAGE_USED_SPACE"] = "getStorageUsedSpace";
        RPCMethodName["GET_STORAGE_PAID_SPACE"] = "getStoragePaidSpace";
        RPCMethodName["GET_TICKET_BALANCE"] = "getTicketBalance";
        RPCMethodName["GET_ALL_TICKET_BALANCES"] = "getAllTicketBalances";
        RPCMethodName["GET_PENDING_OPERATIONS"] = "getPendingOperations";
    })(RPCMethodName || (RPCMethodName = {}));

    /**
     * Casts object/array items to BigNumber
     * @param data input object or array
     * @param keys keys for processing or all items if not defined
     *
     */
    function castToBigNumber(data, keys) {
        const returnArray = Array.isArray(data);
        if (typeof keys === 'undefined') {
            keys = Object.keys(data);
        }
        const response = returnArray ? [] : {};
        keys.forEach((key) => {
            const item = data[key];
            let res;
            if (typeof item === 'undefined') {
                return;
            }
            if (Array.isArray(item)) {
                res = castToBigNumber(item);
                response[key] = res;
                return;
            }
            res = new BigNumber(item);
            response[key] = res;
        });
        return response;
    }

    const defaultTtl = 1000;
    /***
     * @description RpcClientCache acts as a decorator over the RpcClient instance by caching responses for the period defined by the ttl.
     */
    class RpcClientCache {
        /**
         *
         * @param rpcClient rpcClient responsible of the interaction with Tezos network through an rpc node
         * @param ttl number representing the time to live (default 1000 milliseconds)
         *
         * @example new RpcClientCache(new RpcClient('https://mainnet.ecadinfra.com/'))
         */
        constructor(rpcClient, ttl = defaultTtl) {
            this.rpcClient = rpcClient;
            this.ttl = ttl;
            this._cache = {};
        }
        getAllCachedData() {
            return this._cache;
        }
        /**
         * @description Remove all the data in the cache.
         *
         */
        deleteAllCachedData() {
            for (const key in this._cache) {
                delete this._cache[key];
            }
        }
        formatCacheKey(rpcUrl, rpcMethodName, rpcMethodParams, rpcMethodData) {
            let paramsToString = '';
            rpcMethodParams.forEach((param) => {
                paramsToString =
                    typeof param === 'object'
                        ? paramsToString + JSON.stringify(param) + '/'
                        : paramsToString + param + '/';
            });
            return rpcMethodData
                ? `${rpcUrl}/${rpcMethodName}/${paramsToString}${JSON.stringify(rpcMethodData)}/`
                : `${rpcUrl}/${rpcMethodName}/${paramsToString}`;
        }
        has(key) {
            return key in this._cache;
        }
        get(key) {
            return this._cache[key].response;
        }
        put(key, response) {
            const handle = setTimeout(() => {
                return this.remove(key);
            }, this.ttl);
            Object.assign(this._cache, { [key]: { handle, response } });
        }
        remove(key) {
            if (key in this._cache) {
                delete this._cache[key];
            }
        }
        validateAddress(address) {
            const addressValidation = utils.validateAddress(address);
            if (addressValidation !== utils.ValidationResult.VALID) {
                throw new core.InvalidAddressError(address, utils.invalidDetail(addressValidation));
            }
        }
        validateContract(address) {
            const addressValidation = utils.validateContractAddress(address);
            if (addressValidation !== utils.ValidationResult.VALID) {
                throw new core.InvalidContractAddressError(address, utils.invalidDetail(addressValidation));
            }
        }
        /**
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Get the block's hash, its unique identifier.
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-hash
         */
        getBlockHash({ block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_BLOCK_HASH, [
                    block,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getBlockHash({ block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description List the ancestors of the given block which, if referred to as the branch in an operation header, are recent enough for that operation to be included in the current block.
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-live-blocks
         */
        getLiveBlocks({ block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_LIVE_BLOCKS, [
                    block,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getLiveBlocks({ block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         * @param address address from which we want to retrieve the balance
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Access the spendable balance of a contract, excluding frozen bonds
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-balance
         */
        getBalance(address, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateAddress(address);
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_BALANCE, [
                    block,
                    address,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getBalance(address, { block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         * @param address contract address from which we want to retrieve the storage
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Access the data of the contract.
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-storage
         */
        getStorage(address, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateContract(address);
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_STORAGE, [
                    block,
                    address,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getStorage(address, { block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         * @param address contract address from which we want to retrieve the script
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Access the code and data of the contract.
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-script
         */
        getScript(address, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateContract(address);
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_SCRIPT, [
                    block,
                    address,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getScript(address, { block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         * @param address contract address from which we want to retrieve the script
         * @param unparsingMode default is { unparsing_mode: "Readable" }
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Access the script of the contract and normalize it using the requested unparsing mode.
         */
        getNormalizedScript(address, unparsingMode = { unparsing_mode: 'Readable' }, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateContract(address);
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_NORMALIZED_SCRIPT, [block, address], unparsingMode);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getNormalizedScript(address, unparsingMode, { block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         * @param address contract address from which we want to retrieve
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Access the complete status of a contract.
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id
         */
        getContract(address, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateAddress(address);
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_CONTRACT, [
                    block,
                    address,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getContract(address, { block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         * @param address contract address from which we want to retrieve the manager
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Access the manager of an implicit contract
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-manager-key
         */
        getManagerKey(address, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateAddress(address);
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_MANAGER_KEY, [
                    block,
                    address,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getManagerKey(address, { block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         * @param address contract address from which we want to retrieve the delegate (baker)
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Access the delegate of a contract, if any
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-delegate
         */
        getDelegate(address, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateAddress(address);
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_DELEGATE, [
                    block,
                    address,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getDelegate(address, { block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         * @deprecated Deprecated in favor of getBigMapKeyByID
         * @param address contract address from which we want to retrieve the big map key
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Access the value associated with a key in the big map storage of the contract.
         * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-context-contracts-contract-id-big-map-get
         */
        getBigMapKey(address, key, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateAddress(address);
                const keyUrl = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_BIG_MAP_KEY, [block, address], key);
                if (this.has(keyUrl)) {
                    return this.get(keyUrl);
                }
                else {
                    const response = this.rpcClient.getBigMapKey(address, key, { block });
                    this.put(keyUrl, response);
                    return response;
                }
            });
        }
        /**
         * @param id Big Map ID
         * @param expr Expression hash to query (A b58check encoded Blake2b hash of the expression (The expression can be packed using the pack_data method))
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Access the value associated with a key in a big map.
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-big-maps-big-map-id-script-expr
         */
        getBigMapExpr(id, expr, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_BIG_MAP_EXPR, [
                    block,
                    id,
                    expr,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getBigMapExpr(id, expr, { block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         * @param address delegate address which we want to retrieve
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Everything about a delegate
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-delegates-pkh
         */
        getDelegates(address, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateAddress(address);
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_DELEGATES, [
                    block,
                    address,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getDelegates(address, { block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         * @param address delegate address which we want to retrieve
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Returns the delegate info (e.g. voting power) found in the listings of the current voting period
         * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-delegates-pkh-voting-info
         */
        getVotingInfo(address, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateAddress(address);
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_VOTING_INFO, [
                    block,
                    address,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getVotingInfo(address, { block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description All constants
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-constants
         */
        getConstants({ block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_CONSTANTS, [
                    block,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getConstants({ block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         * @param options contains generic configuration for rpc calls to specified block (default to head) and version.
         * @description All the information about a block
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id
         * @example getBlock() will default to `/main/chains/block/head?version=0` which shows { kind: endorsement }
         * @example getBlock({ block: 'head~2', version: 1 }) will return an offset of 2 from head blocks and shows { kind: attestation }
         * @example getBlock({ block: 'BL8fTiWcSxWCjiMVnDkbh6EuhqVPZzgWheJ2dqwrxYRm9AephXh~2' }) will return an offset of 2 blocks from given block hash..
         */
        getBlock({ block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_BLOCK, [block]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getBlock({ block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description The whole block header
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-header
         */
        getBlockHeader({ block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_BLOCK_HEADER, [
                    block,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getBlockHeader({ block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         * @param options contains generic configuration for rpc calls to specified block (default to head) and version
         * @description All the metadata associated to the block
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-metadata
         */
        getBlockMetadata({ block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_BLOCK_METADATA, [
                    block,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getBlockMetadata({ block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         * @param args contains optional query arguments (level, cycle, delegate, consensus_key, and max_round)
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Retrieves the list of delegates allowed to bake a block.
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-helpers-baking-rights
         */
        getBakingRights(args = {}, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_BAKING_RIGHTS, [
                    block,
                    args,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getBakingRights(args, { block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         * @param args contains optional query arguments (level, cycle, delegate, and consensus_key)
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Retrieves the delegates allowed to attest a block
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-helpers-endorsing-rights
         */
        getAttestationRights(args = {}, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_ATTESTATION_RIGHTS, [block, args]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getAttestationRights(args, { block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         * @deprecated Deprecated in favor of getAttestationRights
         * @param args contains optional query arguments (level, cycle, delegate, and consensus_key)
         * @param options contains generic configuration for rpc calls
         * @description Retrieves the delegates allowed to endorse a block
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-helpers-endorsing-rights
         */
        getEndorsingRights(args = {}, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_ENDORSING_RIGHTS, [block, args]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getEndorsingRights(args, { block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Ballots casted so far during a voting period
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-ballot-list
         */
        getBallotList({ block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_BALLOT_LIST, [
                    block,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getBallotList({ block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Sum of ballots casted so far during a voting period
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-ballots
         */
        getBallots({ block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_BALLOTS, [block]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getBallots({ block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Current proposal under evaluation.
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-current-proposal
         */
        getCurrentProposal({ block, } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_CURRENT_PROPOSAL, [block]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getCurrentProposal({ block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Current expected quorum.
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-current-quorum
         */
        getCurrentQuorum({ block, } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_CURRENT_QUORUM, [
                    block,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getCurrentQuorum({ block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description List of delegates with their voting power
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-listings
         */
        getVotesListings({ block, } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_VOTES_LISTINGS, [
                    block,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getVotesListings({ block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description List of proposals with number of supporters
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-proposals
         */
        getProposals({ block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_PROPOSALS, [
                    block,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getProposals({ block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         * @param data operation contents to forge
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Forge an operation returning the unsigned bytes
         * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-forge-operations
         */
        forgeOperations(data, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.rpcClient.forgeOperations(data, { block });
            });
        }
        /**
         * @param signedOpBytes signed bytes to inject
         * @description Inject an operation in node and broadcast it and return the ID of the operation
         * @see https://tezos.gitlab.io/api/rpc.html#post-injection-operation
         */
        injectOperation(signedOpBytes) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.rpcClient.injectOperation(signedOpBytes);
            });
        }
        /**
         * @param ops Operations to apply
         * @param options contains generic configuration for rpc calls to specified block and version
         * @description Simulate the application of the operations with the context of the given block and return the result of each operation application
         * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-preapply-operations
         */
        preapplyOperations(ops, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.rpcClient.preapplyOperations(ops, { block });
            });
        }
        /**
         * @param contract address of the contract we want to get the entrypoints of
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Return the list of entrypoints of the contract
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-entrypoints
         * @version 005_PsBABY5H
         */
        getEntrypoints(contract, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateContract(contract);
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_ENTRYPOINTS, [
                    block,
                    contract,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getEntrypoints(contract, { block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         * @deprecated Deprecated in favor of simulateOperation
         * @param op Operation to run
         * @param options contains generic configuration for rpc calls to specified block and version
         * @description Run an operation with the context of the given block and without signature checks and return the operation application result, including the consumed gas.
         * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-scripts-run-operation
         */
        runOperation(op, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.rpcClient.runOperation(op, { block });
            });
        }
        /**
         * @param op Operation to simulate
         * @param options contains generic configuration for rpc calls to specified block and version
         * @description Simulate running an operation at some future moment (based on the number of blocks given in the `latency` argument), and return the operation application result.
         * @see https://gitlab.com/tezos/tezos/-/blob/master/docs/api/oxford-openapi.json
         */
        simulateOperation(op, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.rpcClient.simulateOperation(op, { block });
            });
        }
        /**
         * @param code Code to run
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Run a Michelson script in the current context
         * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-scripts-run-code
         */
        runCode(code, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.rpcClient.runCode(code, { block });
            });
        }
        /**
         * @param viewScriptParams Parameters of the script view to run
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Simulate a call to a michelson view
         */
        runScriptView(_a, _b) {
            var { unparsing_mode = 'Readable' } = _a, rest = __rest(_a, ["unparsing_mode"]);
            var _c = _b === void 0 ? defaultRPCOptions : _b, block = _c.block;
            return __awaiter(this, void 0, void 0, function* () {
                return this.rpcClient.runScriptView(Object.assign({ unparsing_mode }, rest), { block });
            });
        }
        /**
         * @param viewParams Parameters of the view to run
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Simulate a call to a view following the TZIP-4 standard. See https://gitlab.com/tzip/tzip/-/blob/master/proposals/tzip-4/tzip-4.md#view-entrypoints.
         */
        runView(_a, _b) {
            var { unparsing_mode = 'Readable' } = _a, rest = __rest(_a, ["unparsing_mode"]);
            var _c = _b === void 0 ? defaultRPCOptions : _b, block = _c.block;
            return __awaiter(this, void 0, void 0, function* () {
                return this.rpcClient.runView(Object.assign({ unparsing_mode }, rest), { block });
            });
        }
        getChainId() {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_CHAIN_ID, []);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getChainId();
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         * @param data Data to pack
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Computes the serialized version of a data expression using the same algorithm as script instruction PACK
         * Note: You should always verify the packed bytes before signing or requesting that they be signed when using the the RPC to pack.
         * This precaution helps protect you and your applications users from RPC nodes that have been compromised.
         * A node that is operated by a bad actor, or compromised by a bad actor could return a fully formed operation that does not correspond to the input provided to the RPC endpoint.
         * A safer solution to pack and sign data would be to use the `packDataBytes` function available in the `@taquito/michel-codec` package.
         * @example packData({ data: { string: "test" }, type: { prim: "string" } })
         * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-scripts-pack-data
         */
        packData(data, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.PACK_DATA, [block], data);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.packData(data, { block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         *
         * @description Return rpc root url
         */
        getRpcUrl() {
            return this.rpcClient.getRpcUrl();
        }
        /**
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Returns the voting period (index, kind, starting position) and related information (position, remaining) of the interrogated block
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-current-period
         */
        getCurrentPeriod({ block, } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_CURRENT_PERIOD, [
                    block,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getCurrentPeriod({ block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Returns the voting period (index, kind, starting position) and related information (position, remaining) of the next block.Useful to craft operations that will be valid in the next block
         * @example getSuccessorPeriod() will default to successor voting period for /main/chains/block/head.
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-successor-period
         */
        getSuccessorPeriod({ block, } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_SUCCESSOR_PERIOD, [block]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getSuccessorPeriod({ block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         * @param id Sapling state ID
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Returns the root and a diff of a state starting from an optional offset which is zero by default
         * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-sapling-sapling-state-id-get-diff
         */
        getSaplingDiffById(id, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_SAPLING_DIFF_BY_ID, [block, id]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getSaplingDiffById(id, { block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         * @param contract address of the contract we want to get the sapling diff
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Returns the root and a diff of a state starting from an optional offset which is zero by default
         * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-contracts-contract-id-single-sapling-get-diff
         */
        getSaplingDiffByContract(contract, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_SAPLING_DIFF_BY_CONTRACT, [block, contract]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getSaplingDiffByContract(contract, { block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description get current and next protocol
         * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-protocols
         */
        getProtocols({ block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_PROTOCOLS, [
                    block,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getProtocols({ block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         * @param contract address of the contract we want to retrieve storage information of
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Access the used storage space of the contract
         * @see https://tezos.gitlab.io/lima/rpc.html#get-block-id-context-contracts-contract-id-storage
         */
        getStorageUsedSpace(contract, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_STORAGE_USED_SPACE, [block, contract]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getStorageUsedSpace(contract, { block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         * @param contract address of the contract we want to retrieve storage information of
         * @param options contains generic configuration for rpc calls to specified block (default to head)
      =   * @description Access the paid storage space of the contract
         * @see https://tezos.gitlab.io/lima/rpc.html#get-block-id-context-contracts-contract-id-storage
         */
        getStoragePaidSpace(contract, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_STORAGE_PAID_SPACE, [block, contract]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getStoragePaidSpace(contract, { block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         * @param contract implicit or originated address we want to retrieve ticket balance of
         * @param ticket object to specify a ticket by ticketer, content type and content
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Access the contract's balance of ticket with specified ticketer, content type, and content.
         * @example ticket { ticketer: 'address', content_type: { prim: "string" }, content: { string: 'ticket1' } }
         * @see https://tezos.gitlab.io/protocols/016_mumbai.html#rpc-changes
         */
        getTicketBalance(contract, ticket, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_TICKET_BALANCE, [block, contract], ticket);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getTicketBalance(contract, ticket, { block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         * @param contract originated address we want to retrieve ticket balances of
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Access the complete list of tickets owned by the given contract by scanning the contract's storage.
         * @see https://tezos.gitlab.io/protocols/016_mumbai.html#rpc-changes
         */
        getAllTicketBalances(contract, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_ALL_TICKET_BALANCES, [block, contract]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getAllTicketBalances(contract, { block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         * @description List the prevalidated operations in mempool (accessibility of mempool depends on each rpc endpoint)
         * @param args has 5 optional properties. We support version 1 as default will output { applied: { kind: endorsement} } version 2 will output { validated: { kind: attestation} }. The rest of the properties is to filter pending operations response
         * @default args { version: '1', applied: true, refused: true, outdated, true, branchRefused: true, branchDelayed: true, validationPass: undefined }
         * @see https://tezos.gitlab.io/CHANGES.html?highlight=pending_operations#id4
         */
        getPendingOperations(args = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_PENDING_OPERATIONS, [args]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getPendingOperations(args);
                    this.put(key, response);
                    return response;
                }
            });
        }
    }

    exports.OPERATION_METADATA = void 0;
    (function (OPERATION_METADATA) {
        OPERATION_METADATA["TOO_LARGE"] = "too large";
    })(exports.OPERATION_METADATA || (exports.OPERATION_METADATA = {}));
    exports.METADATA_BALANCE_UPDATES_CATEGORY = void 0;
    (function (METADATA_BALANCE_UPDATES_CATEGORY) {
        METADATA_BALANCE_UPDATES_CATEGORY["BAKING_BONUSES"] = "baking bonuses";
        METADATA_BALANCE_UPDATES_CATEGORY["BAKING_REWARDS"] = "baking rewards";
        METADATA_BALANCE_UPDATES_CATEGORY["BLOCK_FEES"] = "block fees";
        METADATA_BALANCE_UPDATES_CATEGORY["BONDS"] = "bonds";
        METADATA_BALANCE_UPDATES_CATEGORY["BOOTSTRAP"] = "bootstrap";
        METADATA_BALANCE_UPDATES_CATEGORY["BURNED"] = "burned";
        METADATA_BALANCE_UPDATES_CATEGORY["COMMITMENT"] = "commitment";
        METADATA_BALANCE_UPDATES_CATEGORY["DELEGATE_DENOMINATOR"] = "delegate_denominator";
        METADATA_BALANCE_UPDATES_CATEGORY["DELEGATOR_NUMERATOR"] = "delegator_numerator";
        METADATA_BALANCE_UPDATES_CATEGORY["DEPOSITS"] = "deposits";
        METADATA_BALANCE_UPDATES_CATEGORY["ENDORSING_REWARDS"] = "endorsing rewards";
        METADATA_BALANCE_UPDATES_CATEGORY["INVOICE"] = "invoice";
        METADATA_BALANCE_UPDATES_CATEGORY["LOST_ENDORSING_REWARDS"] = "lost endorsing rewards";
        METADATA_BALANCE_UPDATES_CATEGORY["MINTED"] = "minted";
        METADATA_BALANCE_UPDATES_CATEGORY["NONCE_REVELATION_REWARDS"] = "nonce revelation rewards";
        METADATA_BALANCE_UPDATES_CATEGORY["PUNISHMENTS"] = "punishments";
        METADATA_BALANCE_UPDATES_CATEGORY["SMART_ROLLUP_REFUTATION_PUNISHMENTS"] = "smart_rollup_refutation_punishments";
        METADATA_BALANCE_UPDATES_CATEGORY["SMART_ROLLUP_REFUTATION_REWARDS"] = "smart_rollup_refutation_rewards";
        METADATA_BALANCE_UPDATES_CATEGORY["STORAGE_FEES"] = "storage fees";
        METADATA_BALANCE_UPDATES_CATEGORY["SUBSIDY"] = "subsidy";
        METADATA_BALANCE_UPDATES_CATEGORY["UNSTAKED_DEPOSITS"] = "unstaked_deposits";
    })(exports.METADATA_BALANCE_UPDATES_CATEGORY || (exports.METADATA_BALANCE_UPDATES_CATEGORY = {}));
    exports.PvmKind = void 0;
    (function (PvmKind) {
        PvmKind["WASM2"] = "wasm_2_0_0";
        PvmKind["ARITH"] = "arith";
        PvmKind["RISCV"] = "riscv";
    })(exports.PvmKind || (exports.PvmKind = {}));
    exports.SmartRollupRefutationOptions = void 0;
    (function (SmartRollupRefutationOptions) {
        SmartRollupRefutationOptions["START"] = "start";
        SmartRollupRefutationOptions["MOVE"] = "move";
    })(exports.SmartRollupRefutationOptions || (exports.SmartRollupRefutationOptions = {}));
    exports.SmartRollupInputProofKind = void 0;
    (function (SmartRollupInputProofKind) {
        SmartRollupInputProofKind["INBOX_PROOF"] = "inbox_proof";
        SmartRollupInputProofKind["REVEAL_PROOF"] = "reveal_proof";
        SmartRollupInputProofKind["FIRST_INPUT"] = "first_input";
    })(exports.SmartRollupInputProofKind || (exports.SmartRollupInputProofKind = {}));
    exports.SmartRollupRefuteRevealProofKind = void 0;
    (function (SmartRollupRefuteRevealProofKind) {
        SmartRollupRefuteRevealProofKind["RAW_DATA_PROOF"] = "raw_data_proof";
        SmartRollupRefuteRevealProofKind["METADATA_PROOF"] = "metadata_proof";
        SmartRollupRefuteRevealProofKind["DAL_PAGE_PROOF"] = "dal_page_proof";
    })(exports.SmartRollupRefuteRevealProofKind || (exports.SmartRollupRefuteRevealProofKind = {}));
    exports.SmartRollupRefuteGameStatusOptions = void 0;
    (function (SmartRollupRefuteGameStatusOptions) {
        SmartRollupRefuteGameStatusOptions["ONGOING"] = "ongoing";
        SmartRollupRefuteGameStatusOptions["ENDED"] = "ended";
    })(exports.SmartRollupRefuteGameStatusOptions || (exports.SmartRollupRefuteGameStatusOptions = {}));
    exports.SmartRollupRefuteGameEndedPlayerOutcomes = void 0;
    (function (SmartRollupRefuteGameEndedPlayerOutcomes) {
        SmartRollupRefuteGameEndedPlayerOutcomes["LOSER"] = "loser";
        SmartRollupRefuteGameEndedPlayerOutcomes["DRAW"] = "draw";
    })(exports.SmartRollupRefuteGameEndedPlayerOutcomes || (exports.SmartRollupRefuteGameEndedPlayerOutcomes = {}));
    exports.SmartRollupRefuteGameEndedReason = void 0;
    (function (SmartRollupRefuteGameEndedReason) {
        SmartRollupRefuteGameEndedReason["CONFLICT_RESOLVED"] = "conflict_resolved";
        SmartRollupRefuteGameEndedReason["TIMEOUT"] = "timeout";
    })(exports.SmartRollupRefuteGameEndedReason || (exports.SmartRollupRefuteGameEndedReason = {}));

    exports.OpKind = void 0;
    (function (OpKind) {
        OpKind["ORIGINATION"] = "origination";
        OpKind["DELEGATION"] = "delegation";
        OpKind["REVEAL"] = "reveal";
        OpKind["TRANSACTION"] = "transaction";
        OpKind["ACTIVATION"] = "activate_account";
        OpKind["ATTESTATION"] = "attestation";
        OpKind["ENDORSEMENT"] = "endorsement";
        OpKind["PREATTESTATION"] = "preattestation";
        OpKind["PREENDORSEMENT"] = "preendorsement";
        OpKind["SET_DEPOSITS_LIMIT"] = "set_deposits_limit";
        OpKind["DOUBLE_PREATTESTATION_EVIDENCE"] = "double_preattestation_evidence";
        OpKind["DOUBLE_PREENDORSEMENT_EVIDENCE"] = "double_preendorsement_evidence";
        OpKind["ATTESTATION_WITH_SLOT"] = "attestation_with_slot";
        OpKind["ENDORSEMENT_WITH_SLOT"] = "endorsement_with_slot";
        OpKind["SEED_NONCE_REVELATION"] = "seed_nonce_revelation";
        OpKind["DOUBLE_ATTESTATION_EVIDENCE"] = "double_attestation_evidence";
        OpKind["DOUBLE_ENDORSEMENT_EVIDENCE"] = "double_endorsement_evidence";
        OpKind["DOUBLE_BAKING_EVIDENCE"] = "double_baking_evidence";
        OpKind["PROPOSALS"] = "proposals";
        OpKind["BALLOT"] = "ballot";
        OpKind["FAILING_NOOP"] = "failing_noop";
        OpKind["REGISTER_GLOBAL_CONSTANT"] = "register_global_constant";
        OpKind["TRANSFER_TICKET"] = "transfer_ticket";
        OpKind["INCREASE_PAID_STORAGE"] = "increase_paid_storage";
        OpKind["UPDATE_CONSENSUS_KEY"] = "update_consensus_key";
        OpKind["DRAIN_DELEGATE"] = "drain_delegate";
        OpKind["VDF_REVELATION"] = "vdf_revelation";
        OpKind["EVENT"] = "event";
        OpKind["TICKET_UPDATES"] = "ticket_updates";
        OpKind["SMART_ROLLUP_ORIGINATE"] = "smart_rollup_originate";
        OpKind["SMART_ROLLUP_ADD_MESSAGES"] = "smart_rollup_add_messages";
        OpKind["SMART_ROLLUP_EXECUTE_OUTBOX_MESSAGE"] = "smart_rollup_execute_outbox_message";
        OpKind["SMART_ROLLUP_PUBLISH"] = "smart_rollup_publish";
        OpKind["SMART_ROLLUP_CEMENT"] = "smart_rollup_cement";
        OpKind["SMART_ROLLUP_RECOVER_BOND"] = "smart_rollup_recover_bond";
        OpKind["SMART_ROLLUP_REFUTE"] = "smart_rollup_refute";
        OpKind["SMART_ROLLUP_TIMEOUT"] = "smart_rollup_timeout";
    })(exports.OpKind || (exports.OpKind = {}));

    // IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!
    const VERSION = {
        "commitHash": "bb48f61207e1806442b0874365e98c7283ba1f68",
        "version": "19.1.0"
    };

    /***
     * @description RpcClient allows interaction with Tezos network through an rpc node
     */
    class RpcClient {
        /**
         *
         * @param url rpc root url
         * @param chain chain (default main)
         * @param httpBackend Http backend that issue http request.
         * You can override it by providing your own if you which to hook in the request/response
         *
         * @example new RpcClient('https://mainnet.ecadinfra.com/', 'main') this will use https://mainnet.ecadinfra.com//chains/main
         */
        constructor(url, chain = defaultChain, httpBackend = new httpUtils.HttpBackend()) {
            this.url = url;
            this.chain = chain;
            this.httpBackend = httpBackend;
        }
        createURL(path) {
            // Trim trailing slashes because it is assumed to be included in path
            // the regex solution is prone to ReDoS. Please see: https://stackoverflow.com/questions/6680825/return-string-without-trailing-slash#comment124306698_6680877
            // We also got a CodeQL error for the regex based solution
            let rootUrl = this.url;
            while (rootUrl.endsWith('/')) {
                rootUrl = rootUrl.slice(0, -1);
            }
            return `${rootUrl}${path}`;
        }
        validateAddress(address) {
            const addressValidation = utils.validateAddress(address);
            if (addressValidation !== utils.ValidationResult.VALID) {
                throw new core.InvalidAddressError(address, utils.invalidDetail(addressValidation));
            }
        }
        validateContract(address) {
            const addressValidation = utils.validateContractAddress(address);
            if (addressValidation !== utils.ValidationResult.VALID) {
                throw new core.InvalidContractAddressError(address, utils.invalidDetail(addressValidation));
            }
        }
        /**
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Get the block's hash, its unique identifier.
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-hash
         */
        getBlockHash({ block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const hash = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/hash`),
                    method: 'GET',
                });
                return hash;
            });
        }
        /**
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description List the ancestors of the given block which, if referred to as the branch in an operation header, are recent enough for that operation to be included in the current block.
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-live-blocks
         */
        getLiveBlocks({ block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const blocks = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/live_blocks`),
                    method: 'GET',
                });
                return blocks;
            });
        }
        /**
         * @param address address from which we want to retrieve the balance
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Access the spendable balance of a contract, excluding frozen bonds
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-balance
         */
        getBalance(address, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateAddress(address);
                const balance = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${address}/balance`),
                    method: 'GET',
                });
                return new BigNumber(balance);
            });
        }
        /**
         * @param address contract address from which we want to retrieve the storage
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Access the data of the contract.
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-storage
         */
        getStorage(address, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateContract(address);
                return this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${address}/storage`),
                    method: 'GET',
                });
            });
        }
        /**
         * @param address contract address from which we want to retrieve the script
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Access the code and data of the contract.
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-script
         */
        getScript(address, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateContract(address);
                return this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${address}/script`),
                    method: 'GET',
                });
            });
        }
        /**
         * @param address contract address from which we want to retrieve the script
         * @param unparsingMode default is { unparsing_mode: "Readable" }
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Access the script of the contract and normalize it using the requested unparsing mode.
         */
        getNormalizedScript(address, unparsingMode = { unparsing_mode: 'Readable' }, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateContract(address);
                return this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${address}/script/normalized`),
                    method: 'POST',
                }, unparsingMode);
            });
        }
        /**
         * @param address contract address from which we want to retrieve
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Access the complete status of a contract.
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id
         */
        getContract(address, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateAddress(address);
                const contractResponse = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${address}`),
                    method: 'GET',
                });
                return Object.assign(Object.assign({}, contractResponse), { balance: new BigNumber(contractResponse.balance) });
            });
        }
        /**
         * @param address contract address from which we want to retrieve the manager
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Access the manager of an implicit contract
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-manager-key
         */
        getManagerKey(address, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateAddress(address);
                return this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${address}/manager_key`),
                    method: 'GET',
                });
            });
        }
        /**
         * @param address contract address from which we want to retrieve the delegate (baker)
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Access the delegate of a contract, if any
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-delegate
         */
        getDelegate(address, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateAddress(address);
                let delegate;
                try {
                    delegate = yield this.httpBackend.createRequest({
                        url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${address}/delegate`),
                        method: 'GET',
                    });
                }
                catch (ex) {
                    if (ex instanceof httpUtils.HttpResponseError && ex.status === httpUtils.STATUS_CODE.NOT_FOUND) {
                        delegate = null;
                    }
                    else {
                        throw ex;
                    }
                }
                return delegate;
            });
        }
        /**
         * @deprecated Deprecated in favor of getBigMapKeyByID
         * @param address contract address from which we want to retrieve the big map key
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Access the value associated with a key in the big map storage of the contract.
         * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-context-contracts-contract-id-big-map-get
         */
        getBigMapKey(address, key, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateAddress(address);
                return this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${address}/big_map_get`),
                    method: 'POST',
                }, key);
            });
        }
        /**
         * @param id Big Map ID
         * @param expr Expression hash to query (A b58check encoded Blake2b hash of the expression (The expression can be packed using the pack_data method))
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Access the value associated with a key in a big map.
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-big-maps-big-map-id-script-expr
         */
        getBigMapExpr(id, expr, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/big_maps/${id}/${expr}`),
                    method: 'GET',
                });
            });
        }
        /**
         * @param address delegate address which we want to retrieve
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Everything about a delegate
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-delegates-pkh
         */
        getDelegates(address, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateAddress(address);
                const response = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/delegates/${address}`),
                    method: 'GET',
                });
                const castedResponse = castToBigNumber(response, [
                    'balance',
                    'full_balance',
                    'current_frozen_deposits',
                    'frozen_deposits',
                    'frozen_balance',
                    'frozen_deposits_limit',
                    'staking_balance',
                    'delegated_balance',
                    'voting_power',
                    'total_delegated_stake',
                    'staking_denominator',
                ]);
                return Object.assign(Object.assign(Object.assign({}, response), castedResponse), { frozen_balance_by_cycle: response.frozen_balance_by_cycle
                        ? response.frozen_balance_by_cycle.map((_a) => {
                            var { deposit, deposits, fees, rewards } = _a, rest = __rest(_a, ["deposit", "deposits", "fees", "rewards"]);
                            const castedToBigNumber = castToBigNumber({ deposit, deposits, fees, rewards }, [
                                'deposit',
                                'deposits',
                                'fees',
                                'rewards',
                            ]);
                            return Object.assign(Object.assign({}, rest), { deposit: castedToBigNumber.deposit, deposits: castedToBigNumber.deposits, fees: castedToBigNumber.fees, rewards: castedToBigNumber.rewards });
                        })
                        : undefined });
            });
        }
        /**
         * @param address delegate address which we want to retrieve
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Returns the delegate info (e.g. voting power) found in the listings of the current voting period
         * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-delegates-pkh-voting-info
         */
        getVotingInfo(address, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateAddress(address);
                return yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/delegates/${address}/voting_info`),
                    method: 'GET',
                });
            });
        }
        /**
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description All constants
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-constants
         */
        getConstants({ block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/constants`),
                    method: 'GET',
                });
                const castedResponse = castToBigNumber(response, [
                    'time_between_blocks',
                    'hard_gas_limit_per_operation',
                    'hard_gas_limit_per_block',
                    'proof_of_work_threshold',
                    'tokens_per_roll',
                    'seed_nonce_revelation_tip',
                    'block_security_deposit',
                    'endorsement_security_deposit',
                    'block_reward',
                    'endorsement_reward',
                    'cost_per_byte',
                    'hard_storage_limit_per_operation',
                    'test_chain_duration',
                    'baking_reward_per_endorsement',
                    'delay_per_missing_endorsement',
                    'minimal_block_delay',
                    'liquidity_baking_subsidy',
                    'cache_layout',
                    'baking_reward_fixed_portion',
                    'baking_reward_bonus_per_slot',
                    'endorsing_reward_per_slot',
                    'double_baking_punishment',
                    'delay_increment_per_round',
                    'tx_rollup_commitment_bond',
                    'vdf_difficulty',
                    'sc_rollup_stake_amount',
                    'minimal_stake',
                ]);
                return Object.assign(Object.assign({}, response), castedResponse);
            });
        }
        /**
         * @param options contains generic configuration for rpc calls to specified block (default to head) and version.
         * @description All the information about a block
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id
         * @example getBlock() will default to `/main/chains/block/head?version=0` which shows { kind: endorsement }
         * @example getBlock({ block: 'head~2', version: 1 }) will return an offset of 2 from head blocks and shows { kind: attestation }
         * @example getBlock({ block: 'BL8fTiWcSxWCjiMVnDkbh6EuhqVPZzgWheJ2dqwrxYRm9AephXh~2' }) will return an offset of 2 blocks from given block hash..
         */
        getBlock({ block, version } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const requestOptions = {
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}`),
                    method: 'GET',
                };
                if (version !== undefined) {
                    requestOptions.query = { version };
                }
                return yield this.httpBackend.createRequest(requestOptions);
            });
        }
        /**
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description The whole block header
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-header
         */
        getBlockHeader({ block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/header`),
                    method: 'GET',
                });
                return response;
            });
        }
        /**
         * @param options contains generic configuration for rpc calls to specified block (default to head) and version
         * @description All the metadata associated to the block
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-metadata
         */
        getBlockMetadata({ block, version, } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const requestOptions = {
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/metadata`),
                    method: 'GET',
                };
                if (version !== undefined) {
                    requestOptions.query = { version };
                }
                return yield this.httpBackend.createRequest(requestOptions);
            });
        }
        /**
         * @param args contains optional query arguments (level, cycle, delegate, consensus_key, and max_round)
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Retrieves the list of delegates allowed to bake a block.
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-helpers-baking-rights
         */
        getBakingRights(args = {}, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/baking_rights`),
                    method: 'GET',
                    query: args,
                });
                return response;
            });
        }
        /**
         * @param args contains optional query arguments (level, cycle, delegate, and consensus_key)
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Retrieves the delegates allowed to attest a block
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-helpers-endorsing-rights
         */
        getAttestationRights(args = {}, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/attestation_rights`),
                    method: 'GET',
                    query: args,
                });
                return response;
            });
        }
        /**
         * @deprecated Deprecated in favor of getAttestationRights
         * @param args contains optional query arguments (level, cycle, delegate, and consensus_key)
         * @param options contains generic configuration for rpc calls
         * @description Retrieves the delegates allowed to endorse a block
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-helpers-endorsing-rights
         */
        getEndorsingRights(args = {}, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/endorsing_rights`),
                    method: 'GET',
                    query: args,
                });
                return response;
            });
        }
        /**
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Ballots casted so far during a voting period
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-ballot-list
         */
        getBallotList({ block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/votes/ballot_list`),
                    method: 'GET',
                });
                return response;
            });
        }
        /**
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Sum of ballots casted so far during a voting period
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-ballots
         */
        getBallots({ block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/votes/ballots`),
                    method: 'GET',
                });
                const casted = castToBigNumber(response, ['yay', 'nay', 'pass']);
                return casted;
            });
        }
        /**
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Current proposal under evaluation.
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-current-proposal
         */
        getCurrentProposal({ block, } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/votes/current_proposal`),
                    method: 'GET',
                });
                return response;
            });
        }
        /**
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Current expected quorum.
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-current-quorum
         */
        getCurrentQuorum({ block, } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/votes/current_quorum`),
                    method: 'GET',
                });
                return response;
            });
        }
        /**
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description List of delegates with their voting power
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-listings
         */
        getVotesListings({ block, } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/votes/listings`),
                    method: 'GET',
                });
                response.map((item) => {
                    if (item.voting_power) {
                        item.voting_power = new BigNumber(item.voting_power);
                    }
                    return item;
                });
                return response;
            });
        }
        /**
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description List of proposals with number of supporters
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-proposals
         */
        getProposals({ block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/votes/proposals`),
                    method: 'GET',
                });
                response.map((item) => {
                    return (item[1] = new BigNumber(item[1]));
                });
                return response;
            });
        }
        /**
         * @param data operation contents to forge
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Forge an operation returning the unsigned bytes
         * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-forge-operations
         */
        forgeOperations(data, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/forge/operations`),
                    method: 'POST',
                }, data);
            });
        }
        /**
         * @param signedOpBytes signed bytes to inject
         * @description Inject an operation in node and broadcast it and return the ID of the operation
         * @see https://tezos.gitlab.io/api/rpc.html#post-injection-operation
         */
        injectOperation(signedOpBytes) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.httpBackend.createRequest({
                    url: this.createURL(`/injection/operation`),
                    method: 'POST',
                }, signedOpBytes);
            });
        }
        /**
         * @param ops Operations to apply
         * @param options contains generic configuration for rpc calls to specified block and version
         * @description Simulate the application of the operations with the context of the given block and return the result of each operation application
         * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-preapply-operations
         */
        preapplyOperations(ops, { block, version } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const requestOptions = {
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/preapply/operations`),
                    method: 'POST',
                };
                if (version !== undefined) {
                    requestOptions.query = { version };
                }
                return yield this.httpBackend.createRequest(requestOptions, ops);
            });
        }
        /**
         * @param contract address of the contract we want to get the entrypoints of
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Return the list of entrypoints of the contract
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-entrypoints
         * @version 005_PsBABY5H
         */
        getEntrypoints(contract, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateContract(contract);
                const contractResponse = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${contract}/entrypoints`),
                    method: 'GET',
                });
                return contractResponse;
            });
        }
        /**
         * @deprecated Deprecated in favor of simulateOperation
         * @param op Operation to run
         * @param options contains generic configuration for rpc calls to specified block and version
         * @description Run an operation with the context of the given block and without signature checks and return the operation application result, including the consumed gas.
         * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-scripts-run-operation
         */
        runOperation(op, { block, version } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const requestOptions = {
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/scripts/run_operation`),
                    method: 'POST',
                };
                if (version !== undefined) {
                    requestOptions.query = { version };
                }
                return yield this.httpBackend.createRequest(requestOptions, op);
            });
        }
        /**
         * @param op Operation to simulate
         * @param options contains generic configuration for rpc calls to specified block and version
         * @description Simulate running an operation at some future moment (based on the number of blocks given in the `latency` argument), and return the operation application result.
         * @see https://gitlab.com/tezos/tezos/-/blob/master/docs/api/oxford-openapi.json
         */
        simulateOperation(op, { block, version } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const requestOptions = {
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/scripts/simulate_operation`),
                    method: 'POST',
                };
                if (version !== undefined) {
                    requestOptions.query = { version };
                }
                return yield this.httpBackend.createRequest(requestOptions, op);
            });
        }
        /**
         * @param code Code to run
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Run a Michelson script in the current context
         * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-scripts-run-code
         */
        runCode(code, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/scripts/run_code`),
                    method: 'POST',
                }, code);
                return response;
            });
        }
        /**
         * @param viewScriptParams Parameters of the script view to run
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Simulate a call to a michelson view
         */
        runScriptView(_a, _b) {
            var { unparsing_mode = 'Readable' } = _a, rest = __rest(_a, ["unparsing_mode"]);
            var _c = _b === void 0 ? defaultRPCOptions : _b, block = _c.block;
            return __awaiter(this, void 0, void 0, function* () {
                return this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/scripts/run_script_view`),
                    method: 'POST',
                }, Object.assign({ unparsing_mode }, rest));
            });
        }
        /**
         * @param viewParams Parameters of the view to run
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Simulate a call to a view following the TZIP-4 standard. See https://gitlab.com/tzip/tzip/-/blob/master/proposals/tzip-4/tzip-4.md#view-entrypoints.
         */
        runView(_a, _b) {
            var { unparsing_mode = 'Readable' } = _a, rest = __rest(_a, ["unparsing_mode"]);
            var _c = _b === void 0 ? defaultRPCOptions : _b, block = _c.block;
            return __awaiter(this, void 0, void 0, function* () {
                return this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/scripts/run_view`),
                    method: 'POST',
                }, Object.assign({ unparsing_mode }, rest));
            });
        }
        getChainId() {
            return __awaiter(this, void 0, void 0, function* () {
                return this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/chain_id`),
                    method: 'GET',
                });
            });
        }
        /**
         * @param data Data to pack
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Computes the serialized version of a data expression using the same algorithm as script instruction PACK
         * Note: You should always verify the packed bytes before signing or requesting that they be signed when using the the RPC to pack.
         * This precaution helps protect you and your applications users from RPC nodes that have been compromised.
         * A node that is operated by a bad actor, or compromised by a bad actor could return a fully formed operation that does not correspond to the input provided to the RPC endpoint.
         * A safer solution to pack and sign data would be to use the `packDataBytes` function available in the `@taquito/michel-codec` package.
         * @example packData({ data: { string: "test" }, type: { prim: "string" } })
         * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-scripts-pack-data
         */
        packData(data, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const _a = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/scripts/pack_data`),
                    method: 'POST',
                }, data), { gas } = _a, rest = __rest(_a, ["gas"]);
                let formattedGas = gas;
                const tryBigNumber = new BigNumber(gas || '');
                if (!tryBigNumber.isNaN()) {
                    formattedGas = tryBigNumber;
                }
                return Object.assign({ gas: formattedGas }, rest);
            });
        }
        /**
         *
         * @description Return rpc root url
         */
        getRpcUrl() {
            return this.url;
        }
        /**
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Returns the voting period (index, kind, starting position) and related information (position, remaining) of the interrogated block
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-current-period
         */
        getCurrentPeriod({ block, } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/votes/current_period`),
                    method: 'GET',
                });
                return response;
            });
        }
        /**
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Returns the voting period (index, kind, starting position) and related information (position, remaining) of the next block.Useful to craft operations that will be valid in the next block
         * @example getSuccessorPeriod() will default to successor voting period for /main/chains/block/head.
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-successor-period
         */
        getSuccessorPeriod({ block, } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/votes/successor_period`),
                    method: 'GET',
                });
                return response;
            });
        }
        /**
         * @param id Sapling state ID
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Returns the root and a diff of a state starting from an optional offset which is zero by default
         * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-sapling-sapling-state-id-get-diff
         */
        getSaplingDiffById(id, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/sapling/${id}/get_diff`),
                    method: 'GET',
                });
            });
        }
        /**
         * @param contract address of the contract we want to get the sapling diff
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Returns the root and a diff of a state starting from an optional offset which is zero by default
         * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-contracts-contract-id-single-sapling-get-diff
         */
        getSaplingDiffByContract(contract, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${contract}/single_sapling_get_diff`),
                    method: 'GET',
                });
            });
        }
        /**
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description get current and next protocol
         * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-protocols
         */
        getProtocols({ block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/protocols`),
                    method: 'GET',
                });
            });
        }
        /**
         * @param contract address of the contract we want to retrieve storage information of
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Access the used storage space of the contract
         * @see https://tezos.gitlab.io/lima/rpc.html#get-block-id-context-contracts-contract-id-storage
         */
        getStorageUsedSpace(contract, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${contract}/storage/used_space`),
                    method: 'GET',
                });
            });
        }
        /**
         * @param contract address of the contract we want to retrieve storage information of
         * @param options contains generic configuration for rpc calls to specified block (default to head)
      =   * @description Access the paid storage space of the contract
         * @see https://tezos.gitlab.io/lima/rpc.html#get-block-id-context-contracts-contract-id-storage
         */
        getStoragePaidSpace(contract, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${contract}/storage/paid_space`),
                    method: 'GET',
                });
            });
        }
        /**
         * @param contract implicit or originated address we want to retrieve ticket balance of
         * @param ticket object to specify a ticket by ticketer, content type and content
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Access the contract's balance of ticket with specified ticketer, content type, and content.
         * @example ticket { ticketer: 'address', content_type: { prim: "string" }, content: { string: 'ticket1' } }
         * @see https://tezos.gitlab.io/protocols/016_mumbai.html#rpc-changes
         */
        getTicketBalance(contract, ticket, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${contract}/ticket_balance`),
                    method: 'POST',
                }, ticket);
            });
        }
        /**
         * @param contract originated address we want to retrieve ticket balances of
         * @param options contains generic configuration for rpc calls to specified block (default to head)
         * @description Access the complete list of tickets owned by the given contract by scanning the contract's storage.
         * @see https://tezos.gitlab.io/protocols/016_mumbai.html#rpc-changes
         */
        getAllTicketBalances(contract, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${contract}/all_ticket_balances`),
                    method: 'GET',
                });
            });
        }
        /**
         * @description List the prevalidated operations in mempool (accessibility of mempool depends on each rpc endpoint)
         * @param args has 5 optional properties. We support version 1 as default will output { applied: { kind: endorsement} } version 2 will output { validated: { kind: attestation} }. The rest of the properties is to filter pending operations response
         * @default args { version: '1', applied: true, refused: true, outdated, true, branchRefused: true, branchDelayed: true, validationPass: undefined }
         * @see https://tezos.gitlab.io/CHANGES.html?highlight=pending_operations#id4
         */
        getPendingOperations(args = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/mempool/pending_operations`),
                    method: 'GET',
                    query: args,
                });
            });
        }
    }

    exports.RpcClient = RpcClient;
    exports.RpcClientCache = RpcClientCache;
    exports.VERSION = VERSION;
    exports.castToBigNumber = castToBigNumber;
    exports.defaultChain = defaultChain;
    exports.defaultRPCOptions = defaultRPCOptions;

}));
//# sourceMappingURL=taquito-rpc.umd.js.map

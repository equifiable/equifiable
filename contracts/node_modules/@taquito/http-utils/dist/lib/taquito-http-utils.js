"use strict";
/**
 * @packageDocumentation
 * @module @taquito/http-utils
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpBackend = exports.HttpTimeoutError = exports.HttpResponseError = exports.HttpRequestFailed = exports.VERSION = void 0;
let fetch = globalThis === null || globalThis === void 0 ? void 0 : globalThis.fetch;
// Will only use browser fetch if we are in a browser environment,
// default to the more stable node-fetch otherwise
const isNode = typeof process !== 'undefined' && !!((_a = process === null || process === void 0 ? void 0 : process.versions) === null || _a === void 0 ? void 0 : _a.node);
if (isNode) {
    fetch = require('node-fetch');
}
const errors_1 = require("./errors");
__exportStar(require("./status_code"), exports);
var version_1 = require("./version");
Object.defineProperty(exports, "VERSION", { enumerable: true, get: function () { return version_1.VERSION; } });
var errors_2 = require("./errors");
Object.defineProperty(exports, "HttpRequestFailed", { enumerable: true, get: function () { return errors_2.HttpRequestFailed; } });
Object.defineProperty(exports, "HttpResponseError", { enumerable: true, get: function () { return errors_2.HttpResponseError; } });
Object.defineProperty(exports, "HttpTimeoutError", { enumerable: true, get: function () { return errors_2.HttpTimeoutError; } });
class HttpBackend {
    constructor(timeout = 30000) {
        this.timeout = timeout;
    }
    serialize(obj) {
        if (!obj) {
            return '';
        }
        const str = [];
        for (const p in obj) {
            // eslint-disable-next-line no-prototype-builtins
            if (obj.hasOwnProperty(p) && typeof obj[p] !== 'undefined') {
                const prop = typeof obj[p].toJSON === 'function' ? obj[p].toJSON() : obj[p];
                // query arguments can have no value so we need some way of handling that
                // example https://domain.com/query?all
                if (prop === null) {
                    str.push(encodeURIComponent(p));
                    continue;
                }
                // another use case is multiple arguments with the same name
                // they are passed as array
                if (Array.isArray(prop)) {
                    prop.forEach((item) => {
                        str.push(encodeURIComponent(p) + '=' + encodeURIComponent(item));
                    });
                    continue;
                }
                str.push(encodeURIComponent(p) + '=' + encodeURIComponent(prop));
            }
        }
        const serialized = str.join('&');
        if (serialized) {
            return `?${serialized}`;
        }
        else {
            return '';
        }
    }
    /**
     *
     * @param options contains options to be passed for the HTTP request (url, method and timeout)
     * @throws {@link HttpRequestFailed} | {@link HttpResponseError} | {@link HttpTimeoutError}
     */
    createRequest({ url, method, timeout = this.timeout, query, headers = {}, json = true }, data) {
        return __awaiter(this, void 0, void 0, function* () {
            // Serializes query params
            const urlWithQuery = url + this.serialize(query);
            // Adds default header entry if there aren't any Content-Type header
            if (!headers['Content-Type']) {
                headers['Content-Type'] = 'application/json';
            }
            // Creates a new AbortController instance to handle timeouts
            const controller = new AbortController();
            const t = setTimeout(() => controller.abort(), timeout);
            try {
                const response = yield fetch(urlWithQuery, {
                    method,
                    headers,
                    body: JSON.stringify(data),
                    signal: controller.signal,
                });
                if (typeof response === 'undefined') {
                    throw new Error('Response is undefined');
                }
                // Handle responses with status code >= 400
                if (response.status >= 400) {
                    const errorData = yield response.text();
                    throw new errors_1.HttpResponseError(`Http error response: (${response.status}) ${errorData}`, response.status, response.statusText, errorData, urlWithQuery);
                }
                if (json) {
                    return response.json();
                }
                else {
                    return response.text();
                }
            }
            catch (e) {
                if (e instanceof Error && e.name === 'AbortError') {
                    throw new errors_1.HttpTimeoutError(timeout, urlWithQuery);
                }
                else if (e instanceof errors_1.HttpResponseError) {
                    throw e;
                }
                else {
                    throw new errors_1.HttpRequestFailed(String(method), urlWithQuery, e);
                }
            }
            finally {
                clearTimeout(t);
            }
        });
    }
}
exports.HttpBackend = HttpBackend;

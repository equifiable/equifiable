"use strict";
/**
 * @packageDocumentation
 * @module @taquito/local-forging
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.localForger = exports.LocalForger = exports.getCodec = exports.ProtocolsHash = exports.VERSION = exports.opMappingReverse = exports.opMapping = exports.CODEC = void 0;
const constants_1 = require("./constants");
const decoder_1 = require("./decoder");
const encoder_1 = require("./encoder");
const uint8array_consumer_1 = require("./uint8array-consumer");
const utils_1 = require("@taquito/utils");
const errors_1 = require("./errors");
const validator_1 = require("./validator");
const protocols_1 = require("./protocols");
const core_1 = require("@taquito/core");
var constants_2 = require("./constants");
Object.defineProperty(exports, "CODEC", { enumerable: true, get: function () { return constants_2.CODEC; } });
Object.defineProperty(exports, "opMapping", { enumerable: true, get: function () { return constants_2.opMapping; } });
Object.defineProperty(exports, "opMappingReverse", { enumerable: true, get: function () { return constants_2.opMappingReverse; } });
__exportStar(require("./decoder"), exports);
__exportStar(require("./encoder"), exports);
__exportStar(require("./uint8array-consumer"), exports);
__exportStar(require("./interface"), exports);
var version_1 = require("./version");
Object.defineProperty(exports, "VERSION", { enumerable: true, get: function () { return version_1.VERSION; } });
var protocols_2 = require("./protocols");
Object.defineProperty(exports, "ProtocolsHash", { enumerable: true, get: function () { return protocols_2.ProtocolsHash; } });
const PROTOCOL_CURRENT = protocols_1.ProtocolsHash.ProxfordY;
function getCodec(codec, _proto) {
    return {
        encoder: encoder_1.encoders[codec],
        decoder: (hex) => {
            const consumer = uint8array_consumer_1.Uint8ArrayConsumer.fromHexString(hex);
            return decoder_1.decoders[codec](consumer);
        },
    };
}
exports.getCodec = getCodec;
//
class LocalForger {
    constructor(protocolHash = PROTOCOL_CURRENT) {
        this.protocolHash = protocolHash;
        this.codec = getCodec(constants_1.CODEC.MANAGER, this.protocolHash);
    }
    forge(params) {
        const branchValidation = (0, utils_1.validateBlock)(params.branch);
        if (branchValidation !== utils_1.ValidationResult.VALID) {
            throw new core_1.InvalidBlockHashError(params.branch, (0, utils_1.invalidDetail)(branchValidation));
        }
        for (const content of params.contents) {
            if (!(0, validator_1.validateOperationKind)(content.kind)) {
                throw new core_1.InvalidOperationKindError(content.kind);
            }
            const diff = (0, validator_1.validateMissingProperty)(content);
            if (diff.length === 1) {
                if (content.kind === 'delegation' && diff[0] === 'delegate') {
                    continue;
                }
                else if (content.kind === 'origination' && diff[0] === 'delegate') {
                    continue;
                }
                else if (content.kind === 'transaction' && diff[0] === 'parameters') {
                    continue;
                }
                else if (content.kind === 'set_deposits_limit' && diff[0] === 'limit') {
                    continue;
                }
                else if (content.kind === 'smart_rollup_originate' && diff[0] === 'whitelist') {
                    continue;
                }
                else {
                    throw new errors_1.InvalidOperationSchemaError(content, `missing properties "${diff.join(', ')}"`);
                }
            }
            else if (diff.length > 1) {
                throw new errors_1.InvalidOperationSchemaError(content, `missing properties "${diff.join(', ')}"`);
            }
        }
        const forged = this.codec.encoder(params).toLowerCase();
        return Promise.resolve(forged);
    }
    parse(hex) {
        return Promise.resolve(this.codec.decoder(hex));
    }
}
exports.LocalForger = LocalForger;
exports.localForger = new LocalForger();

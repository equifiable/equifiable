archetype rsu_agreement(
    share_address : address, 
    recipient : address, 
    company_address : address, 
    expiration_date : date, 
    vesting : list<date * nat>  // Vesting schedule with dates and amounts
)

record balances {granted : nat; vested : nat; transferred : nat; remaining : nat}

asset executions identified by executed_at {executed_at : date; executed_amount : nat}

variable transferred_tokens : nat = 0
variable termination_date : option<date> = none
variable terminated : bool = false
variable closed : bool = false

function isExpired() : bool {
    var expired : bool = now > expiration_date;
    return expired;
}

function calculateBalance() : balances {
    var vested_tokens : nat = 0;
    var granted_tokens : nat = 0;

    for pair in vesting do
        var beforeTermination : bool = match termination_date with
        | some(tDate) -> pair[0] <= tDate
        | none        -> true
        end;
        var vested : bool = pair[0] < now and beforeTermination;
        vested_tokens += (vested) ? pair[1] : 0;
        granted_tokens += pair[1];
    done;

    var transferred_tokens : nat = transferred_tokens;
    var remaining_tokens : nat ?= int_to_nat(granted_tokens - transferred_tokens); 

    return {
        granted = granted_tokens;
        vested = vested_tokens;
        transferred = transferred_tokens;
        remaining = remaining_tokens
    }
}

entry automatic_execution() {
    called by company_address
    effect {
        var b : balances = calculateBalance();

        var tokens_to_transfer : nat ?= int_to_nat(b.vested - transferred_tokens);

        if tokens_to_transfer > 0 then (
            transfer 0tz to share_address call %transfer<address * address * nat>((self_address, recipient, tokens_to_transfer));
            transferred_tokens += tokens_to_transfer;

            executions.add({
                executed_at = now;
                executed_amount = tokens_to_transfer
            })
        )
    }
}

entry terminate() {
    called by company_address
    require {
        isTerminated : terminated = false otherwise "AlreadyTerminated"
    }
    effect {
        terminated := true;
        termination_date := some(now)
    }
}

entry retrieveExpiredShares() {
    require {
        r1 : isExpired() otherwise "NotExpired";
        r2 : not closed otherwise "AlreadyClosed"
    }
    effect {
        var b : balances = calculateBalance();
        var remaining_tokens : nat = b.remaining;

        if remaining_tokens > 0 then (
            transfer 0tz to share_address call %transfer<address * address * nat>((self_address, company_address, remaining_tokens));
        );

        closed := true;
    }
}

view getBalances() : balances {
    var response : balances = calculateBalance();
    return response;
}

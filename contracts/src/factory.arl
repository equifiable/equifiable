archetype factory(owner : address, newAgreementPrice : tez, newRepurchasePrice : tez)

import "agreement.arl"
import "repurchase.arl"

entry setNewAgreementPrice(newPrice : tez) {
    called by owner
    effect {
        newAgreementPrice := newPrice
    }
}

entry setNewRepurchasePrice(newPrice : tez) {
    called by owner
    effect {
        newRepurchasePrice := newPrice
    }
}

entry create(
    share_address : address, 
    recipient : address, 
    company_address : address, 
    start_date : date, 
    expiration_date : date, 
    strike_price : tez,
    vesting : list<date * nat>,
    post_termination_exercise_window : nat,
    agreement_type: string) {
    called by company_address
    require {
        r1 : transferred = newAgreementPrice otherwise "InsufficientTransfer";
        r2: agreement_type = "SOP" or agreement_type = "RSU" or agreement_type = "BSPCE"
    }
    effect {
        const agreement_op_address : (operation * address) = create_contract(agreement, none, 0tz, {
            share_address = share_address;
            recipient = recipient;
            company_address = company_address;
            expiration_date = expiration_date;
            strike_price = strike_price;
            vesting = vesting;
            start_date = start_date;
            post_termination_exercise_window = post_termination_exercise_window;
            agreement_type = agreement_type;
            contract_type = "agreement"
        });
        operations := [agreement_op_address[0]];

        // Lock the total number of share tokens to the agreement
        var granted_tokens : nat = 0;
        for pair in vesting do
            granted_tokens += pair[1];
        done;
        transfer 0tz to share_address call %transfer<address * address * nat>((company_address, agreement_op_address[1], granted_tokens));
        
        // Transfer the required fee
        transfer transferred to owner;
    }
}

entry createRepurchase(
    company_address : address, 
    share_address : address, 
    start_date : date,
    end_date : date,
    price : tez,
    number_shares : nat,
){
    called by company_address

    require {
        r3 : transferred = price*number_shares + newRepurchasePrice otherwise "InsufficientTransfer"
    }

    effect {
        // Create repurchase with price*number_shares tezos
        const repurchase_op_address : (operation * address) = create_contract(repurchase, none, price*number_shares, {
            share_address = share_address;
            company_address = company_address;
            end_date = end_date;
            start_date = start_date;
            price = price;
            number_total_shares = number_shares;
            contract_type = "repurchase"
        });
        operations := [repurchase_op_address[0]];
        
        // Transfer the required fee
        transfer newRepurchasePrice to owner;
    }
}